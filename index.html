<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIAI25 Scanline Prototyp</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #e8e8e8;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: #f8f8f8;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
            max-width: 100%;
        }

        #display-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .controls {
            margin-top: 20px;
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #frame-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 4px;
            outline: none;
        }

        #frame-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #1a5f5f;
            border-radius: 50%;
            cursor: pointer;
        }

        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            font-size: 0.9rem;
            color: #666;
        }

        .stat {
            display: flex;
            gap: 5px;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            font-weight: 600;
            color: #1a5f5f;
            font-family: 'JetBrains Mono', monospace;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading.hidden {
            display: none;
        }

        .loading-text {
            font-size: 1.1rem;
            color: #1a5f5f;
            margin-top: 15px;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1a5f5f;
            width: 0%;
            transition: width 0.1s;
        }

        .play-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            background: #1a5f5f;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        button:hover {
            background: #247373;
        }

        button:disabled {
            background: #aaa;
            cursor: not-allowed;
        }

        #speed-display {
            font-family: 'JetBrains Mono', monospace;
            color: #666;
            min-width: 50px;
        }

        .debug-panel {
            margin-top: 30px;
            width: 100%;
            max-width: 1200px;
            background: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: #0f0;
        }

        .debug-panel h3 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .debug-level {
            margin-bottom: 8px;
            padding: 8px;
            background: #333;
            border-radius: 4px;
        }

        .debug-level.active {
            border-left: 3px solid #0f0;
        }

        .tuning-panel {
            margin-top: 20px;
            width: 100%;
            max-width: 1200px;
            background: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .tuning-panel h3 {
            margin-bottom: 15px;
            font-size: 0.95rem;
            color: #333;
        }

        .tuning-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .tuning-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .tuning-item label {
            font-size: 0.8rem;
            color: #666;
        }

        .tuning-item input[type="range"] {
            width: 100%;
        }

        .tuning-item .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: #1a5f5f;
        }

        .export-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .export-section label {
            font-size: 0.8rem;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .export-row {
            display: flex;
            gap: 10px;
        }

        .export-row input[type="text"] {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f5f5f5;
        }

        .export-row button {
            padding: 8px 12px;
            font-size: 0.8rem;
        }

        .curve-editor {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .curve-editor label {
            font-size: 0.8rem;
            color: #666;
            display: block;
            margin-bottom: 8px;
        }

        .curve-canvas-container {
            position: relative;
            background: #f0f0f0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        #curve-canvas {
            display: block;
            cursor: crosshair;
        }

        .curve-axis-label {
            position: absolute;
            font-size: 0.65rem;
            color: #999;
        }

        .curve-axis-label.y-axis {
            left: 2px;
            top: 2px;
        }

        .curve-axis-label.x-axis {
            right: 2px;
            bottom: 2px;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">Generiere Frames...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <h1>WIAI25 Progressive Enhancement Prototyp</h1>

    <div class="canvas-container">
        <canvas id="display-canvas" width="1200" height="480"></canvas>
    </div>

    <div class="controls">
        <div class="slider-row">
            <input type="range" id="frame-slider" min="0" max="100" value="0">
        </div>

        <div class="stats">
            <div class="stat">
                <span class="stat-label">Frame:</span>
                <span class="stat-value" id="frame-num">0</span>
                <span class="stat-label">/</span>
                <span class="stat-value" id="frame-total">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Level:</span>
                <span class="stat-value" id="level-num">1</span>
            </div>
            <div class="stat">
                <span class="stat-label">Pixel-Größe:</span>
                <span class="stat-value" id="pixel-size">100</span>
                <span class="stat-label">px</span>
            </div>
            <div class="stat">
                <span class="stat-label">Zellen im Level:</span>
                <span class="stat-value" id="cells-in-level">0</span>
            </div>
        </div>

        <div class="play-controls">
            <button id="play-btn">Play</button>
            <button id="slower-btn">-</button>
            <span id="speed-display">1x</span>
            <button id="faster-btn">+</button>
        </div>
    </div>

    <div class="tuning-panel">
        <h3>Parameter-Tuning</h3>
        <div class="tuning-grid">
            <div class="tuning-item">
                <label>Pixel Opacity</label>
                <input type="range" id="tune-opacity" min="0.1" max="1" step="0.05" value="0.6">
                <span class="value-display" id="tune-opacity-val">0.6</span>
            </div>
            <div class="tuning-item">
                <label>Overlap Threshold</label>
                <input type="range" id="tune-overlap" min="0.1" max="0.8" step="0.05" value="0.4">
                <span class="value-display" id="tune-overlap-val">0.4</span>
            </div>
            <div class="tuning-item">
                <label>Outline Stroke Width</label>
                <input type="range" id="tune-stroke" min="1" max="20" step="1" value="6">
                <span class="value-display" id="tune-stroke-val">6</span>
            </div>
            <div class="tuning-item">
                <label>Outline Color</label>
                <select id="tune-outline-color">
                    <option value="smart" selected>Smart (Kontrast)</option>
                    <option value="#ffffff">Weiß</option>
                    <option value="#1a5f5f">Teal</option>
                    <option value="#000000">Schwarz</option>
                </select>
            </div>
        </div>
        <div class="curve-editor">
            <label>Fade-Kurve (X: Level, Y: Fade zu Weiß) — Punkte draggen</label>
            <div class="curve-canvas-container">
                <canvas id="curve-canvas" width="400" height="200"></canvas>
                <span class="curve-axis-label y-axis">Fade→Weiß</span>
                <span class="curve-axis-label x-axis">Level→</span>
            </div>
        </div>
        <div class="export-section">
            <label>Aktuelle Parameter (zum Kopieren)</label>
            <div class="export-row">
                <input type="text" id="export-field" readonly>
                <button id="copy-btn">Copy</button>
                <button id="apply-btn">Regenerate</button>
            </div>
        </div>
    </div>

    <div class="debug-panel" id="debug-panel">
        <h3>Debug: Level-Statistiken</h3>
        <div id="debug-content"></div>
    </div>

    <script>
        const CONFIG = {
            canvasWidth: 1200,
            canvasHeight: 480,
            text: 'WIAI25',
            fontSize: 380,
            fontFamily: 'JetBrains Mono',
            // Levels 1-14 as per PLAN.md
            pixelSizes: [100, 80, 64, 50, 40, 32, 25, 20, 16, 12, 10, 8],
            pixelColor: '#1a5f5f',
            pixelOpacity: 0.6,
            overlapThreshold: 0.4,
            bgColor: '#f8f8f8',
            // Bezier curve control points for fade [x, y] where x=level(0-1), y=fade(0-1)
            fadeCurve: [[0, 0], [0.2, 0.5], [0.5, 0.7], [1, 0.9]],
            outlineStrokeWidth: 6,
            outlineColor: 'smart' // 'smart', '#ffffff', '#1a5f5f', '#000000'
        };

        // State
        let frames = [];
        let levelStats = []; // Debug stats per level
        let currentFrame = 0;
        let isPlaying = false;
        let playInterval = null;
        const speeds = [0.25, 0.5, 1, 2, 4, 8];
        let speedIndex = 2;

        // DOM Elements
        const displayCanvas = document.getElementById('display-canvas');
        const displayCtx = displayCanvas.getContext('2d');
        const slider = document.getElementById('frame-slider');
        const loading = document.getElementById('loading');
        const progressFill = document.getElementById('progress-fill');

        // Hidden canvas for text mask
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = CONFIG.canvasWidth;
        maskCanvas.height = CONFIG.canvasHeight;
        const maskCtx = maskCanvas.getContext('2d');

        // Generate text mask
        function generateTextMask() {
            maskCtx.fillStyle = 'white';
            maskCtx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

            maskCtx.fillStyle = 'black';
            maskCtx.font = `700 ${CONFIG.fontSize}px "${CONFIG.fontFamily}"`;
            maskCtx.textAlign = 'center';
            maskCtx.textBaseline = 'middle';
            maskCtx.fillText(CONFIG.text, CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2 + 15);
        }

        // Check overlap of a cell with the text mask
        function getCellOverlap(x, y, size) {
            const imageData = maskCtx.getImageData(x, y, size, size);
            const pixels = imageData.data;
            let blackPixels = 0;
            const totalPixels = size * size;

            for (let i = 0; i < pixels.length; i += 4) {
                if (pixels[i] < 128) {
                    blackPixels++;
                }
            }

            return blackPixels / totalPixels;
        }

        // Generate valid cells for a pixel size
        function getValidCells(pixelSize) {
            const cells = [];
            const cols = Math.floor(CONFIG.canvasWidth / pixelSize);
            const rows = Math.floor(CONFIG.canvasHeight / pixelSize);

            const offsetX = (CONFIG.canvasWidth - cols * pixelSize) / 2;
            const offsetY = (CONFIG.canvasHeight - rows * pixelSize) / 2;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = Math.floor(offsetX + col * pixelSize);
                    const y = Math.floor(offsetY + row * pixelSize);
                    const overlap = getCellOverlap(x, y, pixelSize);

                    if (overlap >= CONFIG.overlapThreshold) {
                        cells.push({ x, y, size: pixelSize, overlap });
                    }
                }
            }

            return cells;
        }

        // Lighten a hex color toward white
        function lightenColor(hexColor, amount) {
            // amount: 0 = original, 1 = white
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);

            const newR = Math.round(r + (255 - r) * amount);
            const newG = Math.round(g + (255 - g) * amount);
            const newB = Math.round(b + (255 - b) * amount);

            return `rgb(${newR}, ${newG}, ${newB})`;
        }

        // Store history as array of {cells, level}
        let historyLevels = [];

        // Evaluate cubic bezier curve at t
        function evaluateBezierCurve(points, t) {
            // Interpolate through control points using De Casteljau's algorithm
            // For our use case: find y value for given x (level progress)
            // We'll sample the curve and interpolate
            const n = points.length - 1;
            let result = 0;
            for (let i = 0; i <= n; i++) {
                const binomial = factorial(n) / (factorial(i) * factorial(n - i));
                const basis = binomial * Math.pow(1 - t, n - i) * Math.pow(t, i);
                result += points[i][1] * basis;
            }
            return Math.max(0, Math.min(1, result));
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        // Get fade amount for a given level using the bezier curve
        function getFadeForLevel(historyLevel, currentLevel, totalLevels) {
            // How far through the timeline is this history level relative to current?
            // Level 1 at current level 12 means it's been 11 levels
            const levelsAgo = currentLevel - historyLevel;
            const maxLevelsAgo = totalLevels - 1;
            const t = Math.min(levelsAgo / maxLevelsAgo, 1);
            return evaluateBezierCurve(CONFIG.fadeCurve, t);
        }

        // Render a frame using history levels with color fading
        function renderFrame(frameData) {
            const { level, currentPixels } = frameData;
            const totalLevels = CONFIG.pixelSizes.length;

            // Clear with background
            displayCtx.fillStyle = CONFIG.bgColor;
            displayCtx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

            // Draw all completed history levels (oldest = most faded)
            const completedLevels = historyLevels.filter(h => h.level < level);
            completedLevels.forEach(historyLevel => {
                const fadeAmount = getFadeForLevel(historyLevel.level, level, totalLevels);
                const fadedColor = lightenColor(CONFIG.pixelColor, Math.min(fadeAmount, 0.95));

                displayCtx.fillStyle = fadedColor;
                displayCtx.globalAlpha = CONFIG.pixelOpacity;
                historyLevel.cells.forEach(cell => {
                    displayCtx.fillRect(cell.x, cell.y, cell.size, cell.size);
                });
            });

            // Draw current level pixels (no fade)
            displayCtx.fillStyle = CONFIG.pixelColor;
            displayCtx.globalAlpha = CONFIG.pixelOpacity;
            currentPixels.forEach(cell => {
                displayCtx.fillRect(cell.x, cell.y, cell.size, cell.size);
            });

            // Draw outline
            displayCtx.globalAlpha = 1;
            displayCtx.lineJoin = 'round';
            displayCtx.font = `700 ${CONFIG.fontSize}px "${CONFIG.fontFamily}"`;
            displayCtx.textAlign = 'center';
            displayCtx.textBaseline = 'middle';
            const textX = CONFIG.canvasWidth / 2;
            const textY = CONFIG.canvasHeight / 2 + 15;

            if (CONFIG.outlineColor === 'smart') {
                // Smart outline: dark shadow behind, then white stroke
                // This gives contrast on both light and dark backgrounds
                displayCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                displayCtx.lineWidth = CONFIG.outlineStrokeWidth + 4;
                displayCtx.strokeText(CONFIG.text, textX, textY);
                displayCtx.strokeStyle = '#ffffff';
                displayCtx.lineWidth = CONFIG.outlineStrokeWidth;
                displayCtx.strokeText(CONFIG.text, textX, textY);
            } else {
                displayCtx.lineWidth = CONFIG.outlineStrokeWidth;
                displayCtx.strokeStyle = CONFIG.outlineColor;
                displayCtx.strokeText(CONFIG.text, textX, textY);
            }
        }

        // Update debug panel
        function updateDebugPanel(currentLevel) {
            const content = levelStats.map((stat, i) => {
                const isActive = i + 1 === currentLevel;
                return `
                    <div class="debug-level ${isActive ? 'active' : ''}">
                        <strong>Level ${i + 1}</strong> (${stat.pixelSize}px) |
                        Grid: ${stat.cols}×${stat.rows} = ${stat.totalCells} |
                        Gültig: ${stat.validCells} (${(stat.validCells / stat.totalCells * 100).toFixed(1)}%) |
                        Kumulativ: ${stat.cumulativeFrames}
                    </div>
                `;
            }).join('');
            document.getElementById('debug-content').innerHTML = content;
        }

        // Generate all frames
        async function generateFrames() {
            generateTextMask();

            let frameIndex = 0;
            let totalFrames = 0;

            // First pass: count total frames and gather stats
            for (let level = 0; level < CONFIG.pixelSizes.length; level++) {
                const pixelSize = CONFIG.pixelSizes[level];
                const cols = Math.floor(CONFIG.canvasWidth / pixelSize);
                const rows = Math.floor(CONFIG.canvasHeight / pixelSize);
                const cells = getValidCells(pixelSize);

                totalFrames += cells.length;

                levelStats.push({
                    level: level + 1,
                    pixelSize,
                    cols,
                    rows,
                    totalCells: cols * rows,
                    validCells: cells.length,
                    cumulativeFrames: totalFrames
                });
            }

            console.log('=== WIAI25 Scanline Debug ===');
            console.log('Total frames:', totalFrames);
            console.table(levelStats);

            document.getElementById('frame-total').textContent = totalFrames;
            slider.max = totalFrames - 1;

            // Reset history levels
            historyLevels = [];

            // Second pass: generate frames
            for (let level = 0; level < CONFIG.pixelSizes.length; level++) {
                const pixelSize = CONFIG.pixelSizes[level];
                const cells = getValidCells(pixelSize);

                for (let i = 0; i < cells.length; i++) {
                    const currentPixels = cells.slice(0, i + 1);

                    frames.push({
                        index: frameIndex,
                        level: level + 1,
                        pixelSize: pixelSize,
                        cellsInLevel: cells.length,
                        cellIndex: i + 1,
                        currentPixels: currentPixels
                    });

                    frameIndex++;

                    // Update progress
                    const progress = (frameIndex / totalFrames) * 100;
                    progressFill.style.width = `${progress}%`;

                    // Yield to UI every 50 frames
                    if (frameIndex % 50 === 0) {
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                // Level complete - store cells for history rendering
                historyLevels.push({
                    level: level + 1,
                    cells: cells
                });

                console.log(`Level ${level + 1} complete: ${cells.length} cells`);
            }

            loading.classList.add('hidden');
            updateDebugPanel(1);
            showFrame(0);
        }

        // Show a specific frame
        function showFrame(index) {
            if (index < 0 || index >= frames.length) return;

            currentFrame = index;
            const frame = frames[index];

            renderFrame(frame);

            // Update stats
            document.getElementById('frame-num').textContent = frame.index + 1;
            document.getElementById('level-num').textContent = frame.level;
            document.getElementById('pixel-size').textContent = frame.pixelSize;
            document.getElementById('cells-in-level').textContent = `${frame.cellIndex}/${frame.cellsInLevel}`;

            slider.value = index;
            updateDebugPanel(frame.level);
        }

        // Play controls
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').textContent = isPlaying ? 'Pause' : 'Play';

            if (isPlaying) {
                const interval = 100 / speeds[speedIndex];
                playInterval = setInterval(() => {
                    if (currentFrame < frames.length - 1) {
                        showFrame(currentFrame + 1);
                    } else {
                        togglePlay();
                    }
                }, interval);
            } else {
                clearInterval(playInterval);
            }
        }

        function updateSpeed() {
            document.getElementById('speed-display').textContent = `${speeds[speedIndex]}x`;
            if (isPlaying) {
                clearInterval(playInterval);
                const interval = 100 / speeds[speedIndex];
                playInterval = setInterval(() => {
                    if (currentFrame < frames.length - 1) {
                        showFrame(currentFrame + 1);
                    } else {
                        togglePlay();
                    }
                }, interval);
            }
        }

        // Event listeners
        slider.addEventListener('input', (e) => {
            showFrame(parseInt(e.target.value));
        });

        document.getElementById('play-btn').addEventListener('click', togglePlay);

        document.getElementById('slower-btn').addEventListener('click', () => {
            if (speedIndex > 0) {
                speedIndex--;
                updateSpeed();
            }
        });

        document.getElementById('faster-btn').addEventListener('click', () => {
            if (speedIndex < speeds.length - 1) {
                speedIndex++;
                updateSpeed();
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') {
                showFrame(Math.min(currentFrame + 1, frames.length - 1));
            } else if (e.key === 'ArrowLeft') {
                showFrame(Math.max(currentFrame - 1, 0));
            } else if (e.key === ' ') {
                e.preventDefault();
                togglePlay();
            }
        });

        // Tuning controls
        const tuneOpacity = document.getElementById('tune-opacity');
        const tuneOverlap = document.getElementById('tune-overlap');
        const tuneStroke = document.getElementById('tune-stroke');
        const tuneOutlineColor = document.getElementById('tune-outline-color');
        const exportField = document.getElementById('export-field');

        // Curve editor
        const curveCanvas = document.getElementById('curve-canvas');
        const curveCtx = curveCanvas.getContext('2d');
        const CURVE_PADDING = 20;
        let dragPointIndex = -1;

        function drawCurveEditor() {
            const w = curveCanvas.width;
            const h = curveCanvas.height;
            const plotW = w - CURVE_PADDING * 2;
            const plotH = h - CURVE_PADDING * 2;

            curveCtx.clearRect(0, 0, w, h);

            // Draw grid
            curveCtx.strokeStyle = '#ddd';
            curveCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const x = CURVE_PADDING + (plotW * i / 4);
                const y = CURVE_PADDING + (plotH * i / 4);
                curveCtx.beginPath();
                curveCtx.moveTo(x, CURVE_PADDING);
                curveCtx.lineTo(x, h - CURVE_PADDING);
                curveCtx.stroke();
                curveCtx.beginPath();
                curveCtx.moveTo(CURVE_PADDING, y);
                curveCtx.lineTo(w - CURVE_PADDING, y);
                curveCtx.stroke();
            }

            // Draw curve
            curveCtx.strokeStyle = CONFIG.pixelColor;
            curveCtx.lineWidth = 2;
            curveCtx.beginPath();
            for (let t = 0; t <= 1; t += 0.01) {
                const y = evaluateBezierCurve(CONFIG.fadeCurve, t);
                const px = CURVE_PADDING + t * plotW;
                const py = h - CURVE_PADDING - y * plotH;
                if (t === 0) curveCtx.moveTo(px, py);
                else curveCtx.lineTo(px, py);
            }
            curveCtx.stroke();

            // Draw control points
            CONFIG.fadeCurve.forEach((point, i) => {
                const px = CURVE_PADDING + point[0] * plotW;
                const py = h - CURVE_PADDING - point[1] * plotH;

                curveCtx.fillStyle = i === dragPointIndex ? '#ff6600' : CONFIG.pixelColor;
                curveCtx.beginPath();
                curveCtx.arc(px, py, 8, 0, Math.PI * 2);
                curveCtx.fill();

                curveCtx.fillStyle = '#fff';
                curveCtx.beginPath();
                curveCtx.arc(px, py, 4, 0, Math.PI * 2);
                curveCtx.fill();
            });
        }

        function getCurvePoint(e) {
            const rect = curveCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const w = curveCanvas.width;
            const h = curveCanvas.height;
            const plotW = w - CURVE_PADDING * 2;
            const plotH = h - CURVE_PADDING * 2;

            const normalX = Math.max(0, Math.min(1, (x - CURVE_PADDING) / plotW));
            const normalY = Math.max(0, Math.min(1, 1 - (y - CURVE_PADDING) / plotH));
            return [normalX, normalY];
        }

        function findNearestPoint(e) {
            const [mx, my] = getCurvePoint(e);
            let nearest = -1;
            let minDist = 0.1; // threshold

            CONFIG.fadeCurve.forEach((point, i) => {
                const dist = Math.sqrt(Math.pow(point[0] - mx, 2) + Math.pow(point[1] - my, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = i;
                }
            });
            return nearest;
        }

        curveCanvas.addEventListener('mousedown', (e) => {
            dragPointIndex = findNearestPoint(e);
            if (dragPointIndex >= 0) {
                drawCurveEditor();
            }
        });

        curveCanvas.addEventListener('mousemove', (e) => {
            if (dragPointIndex >= 0) {
                const [x, y] = getCurvePoint(e);
                // First and last points: only allow Y movement
                if (dragPointIndex === 0) {
                    CONFIG.fadeCurve[0] = [0, y];
                } else if (dragPointIndex === CONFIG.fadeCurve.length - 1) {
                    CONFIG.fadeCurve[dragPointIndex] = [1, y];
                } else {
                    CONFIG.fadeCurve[dragPointIndex] = [x, y];
                }
                drawCurveEditor();
                updateExportField();
                // Live preview
                if (frames.length > 0) {
                    showFrame(currentFrame);
                }
            }
        });

        curveCanvas.addEventListener('mouseup', () => {
            dragPointIndex = -1;
            drawCurveEditor();
        });

        curveCanvas.addEventListener('mouseleave', () => {
            if (dragPointIndex >= 0) {
                dragPointIndex = -1;
                drawCurveEditor();
            }
        });

        function updateExportField() {
            const params = {
                pixelOpacity: parseFloat(tuneOpacity.value),
                fadeCurve: CONFIG.fadeCurve.map(p => [Math.round(p[0] * 100) / 100, Math.round(p[1] * 100) / 100]),
                overlapThreshold: parseFloat(tuneOverlap.value),
                outlineStrokeWidth: parseInt(tuneStroke.value),
                outlineColor: tuneOutlineColor.value
            };
            exportField.value = JSON.stringify(params);
        }

        function updateTuningDisplay() {
            document.getElementById('tune-opacity-val').textContent = tuneOpacity.value;
            document.getElementById('tune-overlap-val').textContent = tuneOverlap.value;
            document.getElementById('tune-stroke-val').textContent = tuneStroke.value;
            updateExportField();
            drawCurveEditor();
        }

        // Live update for stroke width (doesn't need regeneration)
        tuneStroke.addEventListener('input', () => {
            CONFIG.outlineStrokeWidth = parseInt(tuneStroke.value);
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Live update for outline color
        tuneOutlineColor.addEventListener('change', () => {
            CONFIG.outlineColor = tuneOutlineColor.value;
            updateExportField();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Live update for opacity (doesn't need regeneration for current frame)
        tuneOpacity.addEventListener('input', () => {
            CONFIG.pixelOpacity = parseFloat(tuneOpacity.value);
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // These need regeneration
        tuneOverlap.addEventListener('input', updateTuningDisplay);

        document.getElementById('copy-btn').addEventListener('click', () => {
            exportField.select();
            navigator.clipboard.writeText(exportField.value);
            document.getElementById('copy-btn').textContent = 'Copied!';
            setTimeout(() => {
                document.getElementById('copy-btn').textContent = 'Copy';
            }, 1500);
        });

        document.getElementById('apply-btn').addEventListener('click', async () => {
            CONFIG.pixelOpacity = parseFloat(tuneOpacity.value);
            CONFIG.overlapThreshold = parseFloat(tuneOverlap.value);
            CONFIG.outlineStrokeWidth = parseInt(tuneStroke.value);
            // fadeCurve is already updated live

            // Reset and regenerate
            frames = [];
            levelStats = [];
            historyLevels = [];
            loading.classList.remove('hidden');
            await generateFrames();
        });

        // Wait for font to load, then generate
        document.fonts.ready.then(() => {
            updateTuningDisplay();
            generateFrames();
        });
    </script>
</body>
</html>
