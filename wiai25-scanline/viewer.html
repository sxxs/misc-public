<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIAI25</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&family=Fira+Code:wght@700&family=Source+Code+Pro:wght@700&family=IBM+Plex+Mono:wght@700&family=Roboto+Mono:wght@700&family=Space+Mono:wght@700&family=Inconsolata:wght@700&family=Ubuntu+Mono:wght@700&family=Courier+Prime:wght@700&family=Anonymous+Pro:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #canvas-container {
            position: relative;
            opacity: 0;
            transition: opacity 0s linear;
        }

        #display-canvas {
            display: block;
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #facc15;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 1rem;
        }

        .loading.hidden {
            display: none;
        }

        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 1rem;
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="loading hidden" id="loading"></div>
    <div id="canvas-container">
        <canvas id="display-canvas"></canvas>
    </div>

    <script>
        // ========== VIEWER CONFIGURATION ==========
        const VIEWER_CONFIG = {
            framesUrl: 'frames.json',      // Frame data file (or frames.lz.json for compressed)
            currentUrl: 'current.json',    // Current frame endpoint (later: wiai.json)
            introFrames: 120,               // Number of frames to play as intro
            introFps: 40,                  // Intro animation speed
            fadeDuration: 1.2,             // Fade-in duration in seconds
            fadeDelay: 0.1                 // When to start fade (0 = immediate)
        };

        // ========== STATE ==========
        let frameData = null;
        let config = null;
        let currentFrame = 0;
        let layoutMode = 'twoline';
        let pulsePhase = 0;
        let isIntroPlaying = false;
        let introStartTime = 0;
        let isVisible = true;          // Track viewport visibility
        let animationId = null;        // For cancelling animation

        // DOM elements
        const canvas = document.getElementById('display-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const loading = document.getElementById('loading');

        // ========== DATA LOADING ==========

        async function loadFrameData() {
            try {
                // Add cache-busting timestamp
                const url = VIEWER_CONFIG.framesUrl + '?t=' + Date.now();
                const response = await fetch(url, { cache: 'no-store' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const text = await response.text();

                // Try to decompress if it looks like LZ-String
                let data;
                try {
                    // Check if it starts with valid JSON
                    if (text.trim().startsWith('{')) {
                        data = JSON.parse(text);
                    } else {
                        // Assume it's LZ-String compressed
                        const decompressed = LZString.decompressFromBase64(text);
                        data = JSON.parse(decompressed);
                    }
                } catch (e) {
                    throw new Error('Invalid frame data format');
                }

                return data;
            } catch (error) {
                throw new Error(`Failed to load frames: ${error.message}`);
            }
        }

        async function loadCurrentFrame() {
            try {
                // Add cache-busting timestamp
                const url = VIEWER_CONFIG.currentUrl + '?t=' + Date.now();
                const response = await fetch(url, { cache: 'no-store' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                return data.currentFrame || data.frame || 0;
            } catch (error) {
                console.warn('Could not load current frame, using last frame:', error);
                return -1; // Will use last frame
            }
        }

        // ========== RENDERING UTILITIES ==========

        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        function evaluateBezierCurve(points, t) {
            const n = points.length - 1;
            let result = 0;
            for (let i = 0; i <= n; i++) {
                const binomial = factorial(n) / (factorial(i) * factorial(n - i));
                const basis = binomial * Math.pow(1 - t, n - i) * Math.pow(t, i);
                result += points[i][1] * basis;
            }
            return Math.max(0, Math.min(1, result));
        }

        function interpolateValue(startVal, endVal, progress) {
            return startVal + (endVal - startVal) * progress;
        }

        function fadeColor(hexColor, bgColor, amount) {
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const bgR = parseInt(bgColor.slice(1, 3), 16);
            const bgG = parseInt(bgColor.slice(3, 5), 16);
            const bgB = parseInt(bgColor.slice(5, 7), 16);
            const newR = Math.round(r + (bgR - r) * amount);
            const newG = Math.round(g + (bgG - g) * amount);
            const newB = Math.round(b + (bgB - b) * amount);
            return `rgb(${newR}, ${newG}, ${newB})`;
        }

        function getFadeForPixel(drawnAtFrame, currentFrame, totalFrames) {
            const drawProgress = totalFrames > 0 ? drawnAtFrame / totalFrames : 0;
            const fadeEveryN = Math.max(1, Math.round(interpolateValue(
                config.fadeEveryNPixelsStart,
                config.fadeEveryNPixelsEnd,
                drawProgress
            )));
            const maxFadeSteps = Math.max(1, Math.round(interpolateValue(
                config.maxFadeStepsStart,
                config.maxFadeStepsEnd,
                drawProgress
            )));
            const framesSince = currentFrame - drawnAtFrame;
            const fadeSteps = Math.floor(framesSince / fadeEveryN);
            const t = Math.min(fadeSteps / maxFadeSteps, 1);
            return evaluateBezierCurve(config.fadeCurve, t);
        }

        function getMaxFadeForLevel(pixelLevel) {
            if (config.fadeLimitLevels === 0 || pixelLevel > config.fadeLimitLevels) {
                return 1.0;
            }
            return 1.0 - pixelLevel * config.fadeLimitStep;
        }

        // ========== MAIN RENDERING ==========

        function renderFrame(frameIndex, highlightMode = 'pulse') {
            const isTwoLine = layoutMode === 'twoline';
            const pixels = isTwoLine ? frameData.frames.twoLine : frameData.frames.singleLine;
            const totalFrames = pixels.length;

            // Clear with background
            ctx.fillStyle = config.bgColor;
            ctx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);

            // Only use pixel-wise fading (the default mode)
            for (let i = 0; i <= frameIndex && i < pixels.length; i++) {
                const pixel = pixels[i];
                const rawFadeAmount = getFadeForPixel(pixel.drawnAtFrame, frameIndex, totalFrames);
                const maxFade = getMaxFadeForLevel(pixel.level);
                const fadeAmount = Math.min(rawFadeAmount, maxFade, 0.95);
                const fadedColor = fadeColor(config.pixelColor, config.bgColor, fadeAmount);

                ctx.fillStyle = fadedColor;
                ctx.globalAlpha = config.pixelOpacity;
                ctx.fillRect(pixel.x, pixel.y, pixel.size, pixel.size);
            }

            // Highlight newest pixel (pulse or intro mode)
            // highlightMode: 'none', 'pulse', 'intro'
            if (highlightMode !== 'none' && frameIndex >= 0 && frameIndex < pixels.length) {
                const newestPixel = pixels[frameIndex];

                if (highlightMode === 'intro') {
                    // Intro highlight: white glow (6px larger) + yellow pixel
                    const introGlowSize = 6;

                    // Draw white glow behind
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(
                        newestPixel.x - introGlowSize / 2,
                        newestPixel.y - introGlowSize / 2,
                        newestPixel.size + introGlowSize,
                        newestPixel.size + introGlowSize
                    );
                    ctx.shadowBlur = 0;

                    // Draw yellow pixel on top
                    ctx.fillStyle = config.pixelColor;
                    ctx.globalAlpha = 1;
                    ctx.fillRect(newestPixel.x, newestPixel.y, newestPixel.size, newestPixel.size);

                } else {
                    // Pulse mode: animated pulse effect
                    const normalizedPhase = (Math.sin(pulsePhase) + 1) / 2;

                    let easedPhase;
                    switch (config.pulseCurve) {
                        case 'ease-in':
                            easedPhase = normalizedPhase * normalizedPhase;
                            break;
                        case 'ease-out':
                            easedPhase = 1 - (1 - normalizedPhase) * (1 - normalizedPhase);
                            break;
                        case 'ease-in-out':
                            easedPhase = normalizedPhase < 0.5
                                ? 2 * normalizedPhase * normalizedPhase
                                : 1 - Math.pow(-2 * normalizedPhase + 2, 2) / 2;
                            break;
                        default:
                            easedPhase = normalizedPhase;
                    }

                    const sizeIncrease = easedPhase * config.pulseScalePixels;
                    const scaledSize = newestPixel.size + sizeIncrease;
                    const offset = sizeIncrease / 2;

                    const brightenAmount = easedPhase * config.pulseBrightness;
                    const r = parseInt(config.pixelColor.slice(1, 3), 16);
                    const g = parseInt(config.pixelColor.slice(3, 5), 16);
                    const b = parseInt(config.pixelColor.slice(5, 7), 16);
                    const brightR = Math.round(r + (255 - r) * brightenAmount);
                    const brightG = Math.round(g + (255 - g) * brightenAmount);
                    const brightB = Math.round(b + (255 - b) * brightenAmount);
                    const brightColor = `rgb(${brightR}, ${brightG}, ${brightB})`;

                    ctx.shadowColor = brightColor;
                    ctx.shadowBlur = 5 + easedPhase * config.pulseGlow * 40;
                    ctx.fillStyle = brightColor;
                    ctx.globalAlpha = Math.min(1, config.pixelOpacity + 0.1 + easedPhase * config.pulseGlow * 0.4);

                    ctx.fillRect(
                        newestPixel.x - offset,
                        newestPixel.y - offset,
                        scaledSize,
                        scaledSize
                    );

                    ctx.shadowBlur = 0;
                }
            }

            // Draw outline
            const level = frameIndex < pixels.length ? pixels[frameIndex].level : config.numLevels;
            const shouldHideOutline = config.outlineHideFromLevel > 0 && level >= config.outlineHideFromLevel;

            if (!shouldHideOutline) {
                ctx.globalAlpha = 1;
                ctx.lineJoin = 'round';
                ctx.lineWidth = config.outlineStrokeWidth;
                ctx.strokeStyle = config.outlineColor;

                if (isTwoLine) {
                    const wiaiSize = config.twoLineWiaiSize;
                    const num25Size = config.twoLine25Size;
                    const gap = config.twoLineGap;
                    const totalHeight = wiaiSize + gap + num25Size;
                    const startY = (config.canvasHeight - totalHeight) / 2 + config.textOffsetY;

                    ctx.textAlign = 'center';
                    ctx.font = `700 ${wiaiSize}px "${config.fontFamily}"`;
                    ctx.textBaseline = 'top';
                    ctx.strokeText('WIAI', config.canvasWidth / 2, startY);

                    ctx.font = `700 ${num25Size}px "${config.fontFamily}"`;
                    ctx.strokeText('25', config.canvasWidth / 2, startY + wiaiSize + gap);
                } else {
                    ctx.font = `700 ${config.fontSize}px "${config.fontFamily}"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeText(config.text, config.canvasWidth / 2, config.canvasHeight / 2 + config.textOffsetY);
                }
            }
        }

        // ========== ANIMATION CONTROL ==========

        function determineLayoutMode() {
            const viewportWidth = window.innerWidth;
            return viewportWidth < config.twoLineBreakpoint ? 'twoline' : 'single';
        }

        function startIntroAnimation(targetFrame) {
            isIntroPlaying = true;
            introStartTime = performance.now();

            const pixels = layoutMode === 'twoline' ? frameData.frames.twoLine : frameData.frames.singleLine;
            const frameDuration = 1000 / VIEWER_CONFIG.introFps;

            // Sample frames from entire range (0 to targetFrame) for more visual movement
            const sampledFrames = [];
            const step = targetFrame / VIEWER_CONFIG.introFrames;
            for (let i = 0; i < VIEWER_CONFIG.introFrames; i++) {
                sampledFrames.push(Math.floor(i * step));
            }
            sampledFrames.push(targetFrame); // Always end with target frame

            // Start fade transition
            setTimeout(() => {
                container.style.transition = `opacity ${VIEWER_CONFIG.fadeDuration}s ease-out`;
                container.style.opacity = '1';
            }, VIEWER_CONFIG.fadeDelay * 1000);

            let introIndex = 0;

            function playIntroFrame() {
                if (introIndex < sampledFrames.length) {
                    const frame = sampledFrames[introIndex];
                    const isLastFrame = introIndex === sampledFrames.length - 1;
                    renderFrame(frame, isLastFrame ? 'pulse' : 'intro');
                    introIndex++;
                    setTimeout(playIntroFrame, frameDuration);
                } else {
                    // Intro complete, start pulse animation
                    isIntroPlaying = false;
                    currentFrame = targetFrame;
                    startPulseAnimation();
                }
            }

            playIntroFrame();
        }

        function startPulseAnimation() {
            let lastTime = performance.now();
            let lastRenderTime = 0;
            // pulseFrequency is designed for ~60fps, so multiply by 60 to get per-second rate
            const pulseSpeed = config.pulseFrequency * 60;
            // Throttle to ~12 FPS for performance (83ms between frames)
            const minFrameInterval = 1000 / 12;

            function animate(currentTime) {
                // Always continue the loop, but only render when visible
                animationId = requestAnimationFrame(animate);

                // Skip rendering if not visible
                if (!isVisible) {
                    lastTime = currentTime; // Keep time in sync
                    return;
                }

                // Throttle to target FPS
                if (currentTime - lastRenderTime < minFrameInterval) {
                    return;
                }

                const deltaTime = (currentTime - lastTime) / 1000; // seconds
                lastTime = currentTime;
                lastRenderTime = currentTime;

                pulsePhase = (pulsePhase + pulseSpeed * deltaTime) % (Math.PI * 2);
                renderFrame(currentFrame, 'pulse');
            }
            animationId = requestAnimationFrame(animate);
        }

        // Setup Intersection Observer for visibility tracking
        function setupVisibilityObserver() {
            const observer = new IntersectionObserver(
                (entries) => {
                    entries.forEach(entry => {
                        isVisible = entry.isIntersecting;
                    });
                },
                { threshold: 0.1 } // Trigger when 10% visible
            );
            observer.observe(container);
        }

        // ========== INITIALIZATION ==========

        async function init() {
            try {
                // Load frame data
                loading.textContent = 'Loading frames...';
                const data = await loadFrameData();
                frameData = data;
                config = data.config;

                // Setup canvas
                canvas.width = config.canvasWidth;
                canvas.height = config.canvasHeight;
                document.body.style.background = config.bgColor;

                // Determine layout mode
                layoutMode = determineLayoutMode();

                // Load current frame
                loading.textContent = 'Loading state...';
                let targetFrame = await loadCurrentFrame();

                // If -1, use last frame
                const pixels = layoutMode === 'twoline' ? frameData.frames.twoLine : frameData.frames.singleLine;
                if (targetFrame < 0 || targetFrame >= pixels.length) {
                    targetFrame = pixels.length - 1;
                }

                // Hide loading
                loading.classList.add('hidden');

                // Wait for font to load
                await document.fonts.ready;

                // Setup visibility tracking for performance
                setupVisibilityObserver();

                // Start intro animation
                startIntroAnimation(targetFrame);

                // Handle window resize
                window.addEventListener('resize', () => {
                    const newMode = determineLayoutMode();
                    if (newMode !== layoutMode) {
                        layoutMode = newMode;
                        // Map frame to new layout
                        const oldPixels = layoutMode === 'twoline' ? frameData.frames.singleLine : frameData.frames.twoLine;
                        const newPixels = layoutMode === 'twoline' ? frameData.frames.twoLine : frameData.frames.singleLine;
                        const progress = currentFrame / oldPixels.length;
                        currentFrame = Math.min(Math.floor(progress * newPixels.length), newPixels.length - 1);
                    }
                });

            } catch (error) {
                loading.classList.add('hidden');
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = error.message;
                document.body.appendChild(errorDiv);
                console.error('Viewer init error:', error);
            }
        }

        // Start
        init();
    </script>
</body>
</html>
