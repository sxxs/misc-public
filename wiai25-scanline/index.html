<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIAI25 Scanline Prototyp</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&family=Fira+Code:wght@700&family=Source+Code+Pro:wght@700&family=IBM+Plex+Mono:wght@700&family=Roboto+Mono:wght@700&family=Space+Mono:wght@700&family=Inconsolata:wght@700&family=Ubuntu+Mono:wght@700&family=Courier+Prime:wght@700&family=Anonymous+Pro:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #e8e8e8;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: #f8f8f8;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
            max-width: 100%;
        }

        #display-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .controls {
            margin-top: 20px;
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #frame-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 4px;
            outline: none;
        }

        #frame-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #1a5f5f;
            border-radius: 50%;
            cursor: pointer;
        }

        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            font-size: 0.9rem;
            color: #666;
        }

        .stat {
            display: flex;
            gap: 5px;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            font-weight: 600;
            color: #1a5f5f;
            font-family: 'JetBrains Mono', monospace;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading.hidden {
            display: none;
        }

        .loading-text {
            font-size: 1.1rem;
            color: #1a5f5f;
            margin-top: 15px;
        }

        .progress-bar {
            width: 300px;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1a5f5f;
            width: 0%;
            transition: width 0.1s;
        }

        .play-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            background: #1a5f5f;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        button:hover {
            background: #247373;
        }

        button:disabled {
            background: #aaa;
            cursor: not-allowed;
        }

        #speed-display {
            font-family: 'JetBrains Mono', monospace;
            color: #666;
            min-width: 50px;
        }

        .debug-panel {
            margin-top: 30px;
            width: 100%;
            max-width: 1200px;
            background: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: #0f0;
        }

        .debug-panel h3 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .debug-level {
            margin-bottom: 8px;
            padding: 8px;
            background: #333;
            border-radius: 4px;
        }

        .debug-level.active {
            border-left: 3px solid #0f0;
        }

        .tuning-panel {
            margin-top: 20px;
            width: 100%;
            max-width: 1200px;
            background: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .tuning-panel h3 {
            margin-bottom: 15px;
            font-size: 0.95rem;
            color: #333;
        }

        .tuning-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .tuning-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .tuning-item label {
            font-size: 0.8rem;
            color: #666;
        }

        .tuning-item input[type="range"] {
            width: 100%;
        }

        .tuning-item .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: #1a5f5f;
        }

        .export-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .export-section label {
            font-size: 0.8rem;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .export-row {
            display: flex;
            gap: 10px;
        }

        .export-row input[type="text"] {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f5f5f5;
        }

        .export-row button {
            padding: 8px 12px;
            font-size: 0.8rem;
        }

        .curve-editor {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .curve-editor label {
            font-size: 0.8rem;
            color: #666;
            display: block;
            margin-bottom: 8px;
        }

        .curve-canvas-container {
            position: relative;
            background: #f0f0f0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        #curve-canvas {
            display: block;
            cursor: crosshair;
        }

        .curve-axis-label {
            position: absolute;
            font-size: 0.65rem;
            color: #999;
        }

        .curve-axis-label.y-axis {
            left: 2px;
            top: 2px;
        }

        .curve-axis-label.x-axis {
            right: 2px;
            bottom: 2px;
        }

        .curve-section {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .curve-editor-item {
            flex: 1;
            min-width: 350px;
        }

        .curve-editor-item h4 {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 8px;
        }

        .pixel-size-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .pixel-size-controls .tuning-item {
            flex: 1;
            min-width: 100px;
        }

        .color-input-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-input-row input[type="color"] {
            width: 40px;
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            padding: 2px;
        }

        .color-input-row input[type="text"] {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 80px;
        }

        .color-section {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
        }

        .color-section .tuning-item {
            min-width: 150px;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">Generiere Frames...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <h1>WIAI25 Progressive Enhancement Prototyp</h1>

    <div class="canvas-container">
        <canvas id="display-canvas" width="1200" height="480"></canvas>
    </div>

    <div class="controls">
        <div class="slider-row">
            <input type="range" id="frame-slider" min="0" max="100" value="0">
        </div>

        <div class="stats">
            <div class="stat">
                <span class="stat-label">Frame:</span>
                <span class="stat-value" id="frame-num">0</span>
                <span class="stat-label">/</span>
                <span class="stat-value" id="frame-total">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Level:</span>
                <span class="stat-value" id="level-num">1</span>
            </div>
            <div class="stat">
                <span class="stat-label">Pixel-Größe:</span>
                <span class="stat-value" id="pixel-size">100</span>
                <span class="stat-label">px</span>
            </div>
            <div class="stat">
                <span class="stat-label">Zellen im Level:</span>
                <span class="stat-value" id="cells-in-level">0</span>
            </div>
            <div class="stat" id="interpolated-values" style="display: none;">
                <span class="stat-label">Fade N:</span>
                <span class="stat-value" id="current-fade-n">1</span>
                <span class="stat-label">| Max Steps:</span>
                <span class="stat-value" id="current-max-steps">10</span>
            </div>
        </div>

        <div class="play-controls">
            <button id="play-btn">Play</button>
            <button id="slower-btn">-</button>
            <span id="speed-display">1x</span>
            <button id="faster-btn">+</button>
            <span style="margin-left: 20px; color: #999;">|</span>
            <button id="layout-toggle-btn" style="margin-left: 10px;">Two-Line (T)</button>
        </div>
    </div>

    <div class="tuning-panel">
        <h3>Parameter-Tuning</h3>
        <div class="color-section">
            <div class="tuning-item">
                <label>Schriftart</label>
                <select id="tune-font">
                    <option value="JetBrains Mono">JetBrains Mono</option>
                    <option value="Fira Code">Fira Code</option>
                    <option value="Source Code Pro">Source Code Pro</option>
                    <option value="IBM Plex Mono">IBM Plex Mono</option>
                    <option value="Roboto Mono">Roboto Mono</option>
                    <option value="Space Mono">Space Mono</option>
                    <option value="Inconsolata">Inconsolata</option>
                    <option value="Ubuntu Mono">Ubuntu Mono</option>
                    <option value="Courier Prime">Courier Prime</option>
                    <option value="Anonymous Pro">Anonymous Pro</option>
                </select>
            </div>
            <div class="tuning-item">
                <label>Farbschema</label>
                <select id="tune-preset">
                    <option value="classic">Klassisch (Teal/Weiß)</option>
                    <option value="dark">Dark Mode</option>
                    <option value="highcontrast" selected>Hoher Kontrast</option>
                    <option value="ocean">Ozean</option>
                    <option value="sunset">Sonnenuntergang</option>
                    <option value="custom">Benutzerdefiniert</option>
                </select>
            </div>
            <div class="tuning-item">
                <label>Hintergrund</label>
                <div class="color-input-row">
                    <input type="color" id="tune-bg-color" value="#000000">
                    <input type="text" id="tune-bg-color-text" value="#000000" maxlength="7">
                </div>
            </div>
            <div class="tuning-item">
                <label>Pixel-Farbe</label>
                <div class="color-input-row">
                    <input type="color" id="tune-pixel-color" value="#facc15">
                    <input type="text" id="tune-pixel-color-text" value="#facc15" maxlength="7">
                </div>
            </div>
        </div>
        <div class="tuning-grid">
            <div class="tuning-item">
                <label>Pixel Opacity</label>
                <input type="range" id="tune-opacity" min="0.1" max="1" step="0.05" value="0.7">
                <span class="value-display" id="tune-opacity-val">0.7</span>
            </div>
            <div class="tuning-item">
                <label>Overlap Threshold</label>
                <input type="range" id="tune-overlap" min="0.1" max="0.8" step="0.05" value="0.3">
                <span class="value-display" id="tune-overlap-val">0.3</span>
            </div>
            <div class="tuning-item">
                <label>Outline Stroke Width</label>
                <input type="range" id="tune-stroke" min="1" max="20" step="1" value="2">
                <span class="value-display" id="tune-stroke-val">2</span>
            </div>
            <div class="tuning-item">
                <label>Outline Color</label>
                <select id="tune-outline-color">
                    <option value="#ffffff">Weiß</option>
                    <option value="#1a5f5f">Teal</option>
                    <option value="#000000" selected>Schwarz</option>
                </select>
            </div>
            <div class="tuning-item">
                <label>Outline ausblenden ab Level</label>
                <input type="range" id="tune-outline-hide" min="0" max="20" step="1" value="0">
                <span class="value-display" id="tune-outline-hide-val">nie</span>
            </div>
            <div class="tuning-item">
                <label>Pixel-Reihenfolge</label>
                <select id="tune-order">
                    <option value="scanline">Scanline</option>
                    <option value="shuffle" selected>Shuffle</option>
                </select>
            </div>
            <div class="tuning-item">
                <label>Fade-Modus</label>
                <select id="tune-fade-mode">
                    <option value="level">Pro Level</option>
                    <option value="pixel" selected>Pro N Pixel</option>
                </select>
            </div>
            <div class="tuning-item" id="fade-n-start-container">
                <label>Fade N Pixel (Start)</label>
                <input type="range" id="tune-fade-n-start" min="1" max="1000" step="1" value="8">
                <span class="value-display" id="tune-fade-n-start-val">8</span>
            </div>
            <div class="tuning-item" id="fade-n-end-container">
                <label>Fade N Pixel (Ende)</label>
                <input type="range" id="tune-fade-n-end" min="1" max="1000" step="1" value="164">
                <span class="value-display" id="tune-fade-n-end-val">164</span>
            </div>
            <div class="tuning-item" id="max-fade-start-container">
                <label>Max Fade Steps (Start)</label>
                <input type="range" id="tune-max-fade-start" min="1" max="1000" step="1" value="145">
                <span class="value-display" id="tune-max-fade-start-val">145</span>
            </div>
            <div class="tuning-item" id="max-fade-end-container">
                <label>Max Fade Steps (Ende)</label>
                <input type="range" id="tune-max-fade-end" min="1" max="1000" step="1" value="695">
                <span class="value-display" id="tune-max-fade-end-val">695</span>
            </div>
            <div class="tuning-item">
                <label>Fade-Limit bis Level</label>
                <input type="range" id="tune-fade-limit-levels" min="0" max="15" step="1" value="4">
                <span class="value-display" id="tune-fade-limit-levels-val">4</span>
            </div>
            <div class="tuning-item">
                <label>Fade-Limit Stufe (%)</label>
                <input type="range" id="tune-fade-limit-step" min="0.01" max="0.1" step="0.01" value="0.02">
                <span class="value-display" id="tune-fade-limit-step-val">2%</span>
            </div>
            <div class="tuning-item">
                <label>Puls-Größe (px)</label>
                <input type="range" id="tune-pulse-scale" min="0" max="10" step="1" value="4">
                <span class="value-display" id="tune-pulse-scale-val">4px</span>
            </div>
            <div class="tuning-item">
                <label>Puls-Glow</label>
                <input type="range" id="tune-pulse-glow" min="0" max="1.5" step="0.1" value="0.8">
                <span class="value-display" id="tune-pulse-glow-val">0.8</span>
            </div>
            <div class="tuning-item">
                <label>Puls-Helligkeit</label>
                <input type="range" id="tune-pulse-brightness" min="0" max="1" step="0.1" value="0.5">
                <span class="value-display" id="tune-pulse-brightness-val">0.5</span>
            </div>
            <div class="tuning-item">
                <label>Puls-Frequenz</label>
                <input type="range" id="tune-pulse-frequency" min="0.05" max="0.5" step="0.05" value="0.2">
                <span class="value-display" id="tune-pulse-frequency-val">0.2</span>
            </div>
            <div class="tuning-item">
                <label>Puls-Kurve</label>
                <select id="tune-pulse-curve">
                    <option value="linear" selected>Linear</option>
                    <option value="ease-in">Ease-In (langsamer Start)</option>
                    <option value="ease-out">Ease-Out (langsames Ende)</option>
                    <option value="ease-in-out">S-Kurve</option>
                </select>
            </div>
        </div>
        <div class="tuning-grid" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
            <div class="tuning-item" style="grid-column: 1 / -1;">
                <label style="font-weight: 600; font-size: 0.9rem;">Two-Line Layout (Mobile)</label>
            </div>
            <div class="tuning-item">
                <label>Breakpoint (px)</label>
                <input type="range" id="tune-twoline-breakpoint" min="300" max="1000" step="10" value="600">
                <span class="value-display" id="tune-twoline-breakpoint-val">600px</span>
            </div>
            <div class="tuning-item">
                <label>Single-Line Schriftgröße</label>
                <input type="range" id="tune-singleline-fontsize" min="100" max="500" step="10" value="320">
                <span class="value-display" id="tune-singleline-fontsize-val">320px</span>
            </div>
            <div class="tuning-item">
                <label>WIAI Schriftgröße (Two-Line)</label>
                <input type="range" id="tune-twoline-wiai" min="80" max="400" step="10" value="200">
                <span class="value-display" id="tune-twoline-wiai-val">200px</span>
            </div>
            <div class="tuning-item">
                <label>25 Schriftgröße (Two-Line)</label>
                <input type="range" id="tune-twoline-25" min="100" max="600" step="10" value="380">
                <span class="value-display" id="tune-twoline-25-val">380px</span>
            </div>
            <div class="tuning-item">
                <label>Zeilenabstand (Two-Line)</label>
                <input type="range" id="tune-twoline-gap" min="-100" max="100" step="5" value="-20">
                <span class="value-display" id="tune-twoline-gap-val">-20px</span>
            </div>
        </div>
        <div class="tuning-grid" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
            <div class="tuning-item" style="grid-column: 1 / -1;">
                <label style="font-weight: 600; font-size: 0.9rem;">Canvas-Dimensionen</label>
            </div>
            <div class="tuning-item">
                <label>Breite (px)</label>
                <input type="range" id="tune-canvas-width" min="400" max="2000" step="50" value="1200">
                <span class="value-display" id="tune-canvas-width-val">1200px</span>
            </div>
            <div class="tuning-item">
                <label>Höhe (px)</label>
                <input type="range" id="tune-canvas-height" min="200" max="1000" step="50" value="480">
                <span class="value-display" id="tune-canvas-height-val">480px</span>
            </div>
            <div class="tuning-item">
                <label>Text Y-Offset (px)</label>
                <input type="range" id="tune-text-offset-y" min="-100" max="100" step="5" value="15">
                <span class="value-display" id="tune-text-offset-y-val">15px</span>
            </div>
        </div>
        <div class="curve-editor">
            <label>Kurven-Editoren — Punkte draggen</label>
            <div class="curve-section">
                <div class="curve-editor-item">
                    <h4>Pixelgrößen-Progression (Y: Größe, X: Level)</h4>
                    <div class="pixel-size-controls">
                        <div class="tuning-item">
                            <label>Max Pixel</label>
                            <input type="range" id="tune-max-pixel" min="20" max="200" step="1" value="180">
                            <span class="value-display" id="tune-max-pixel-val">180px</span>
                        </div>
                        <div class="tuning-item">
                            <label>Min Pixel</label>
                            <input type="range" id="tune-min-pixel" min="2" max="20" step="1" value="4">
                            <span class="value-display" id="tune-min-pixel-val">4px</span>
                        </div>
                        <div class="tuning-item">
                            <label>Anzahl Levels</label>
                            <input type="range" id="tune-num-levels" min="3" max="30" step="1" value="11">
                            <span class="value-display" id="tune-num-levels-val">11</span>
                        </div>
                    </div>
                    <div class="curve-canvas-container">
                        <canvas id="pixel-curve-canvas" width="400" height="200"></canvas>
                        <span class="curve-axis-label y-axis">Größe</span>
                        <span class="curve-axis-label x-axis">Level→</span>
                    </div>
                    <div class="value-display" id="pixel-sizes-preview" style="margin-top: 5px; font-size: 0.7rem; word-break: break-all;"></div>
                </div>
                <div class="curve-editor-item">
                    <h4>Fade-Kurve (Y: Fade zu Weiß, X: Level)</h4>
                    <div class="curve-canvas-container">
                        <canvas id="curve-canvas" width="400" height="200"></canvas>
                        <span class="curve-axis-label y-axis">Fade→Weiß</span>
                        <span class="curve-axis-label x-axis">Level→</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="export-section">
            <label>Parameter (kopieren oder einfügen zum Teilen)</label>
            <div class="export-row">
                <input type="text" id="export-field">
                <button id="copy-btn">Copy</button>
                <button id="apply-btn">Apply & Regenerate</button>
            </div>
        </div>
        <div class="export-section" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #ddd;">
            <label>Frame-Export für Deployment</label>
            <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 0.8rem;">
                    <input type="checkbox" id="compress-export" checked>
                    Komprimieren
                </label>
                <button id="save-frames-btn">Save Frames (JSON)</button>
                <span id="export-size-estimate" style="font-size: 0.75rem; color: #666;"></span>
            </div>
        </div>
    </div>

    <div class="debug-panel" id="debug-panel">
        <h3>Debug: Level-Statistiken</h3>
        <div id="debug-content"></div>
    </div>

    <script>
        // Available monospace fonts
        const AVAILABLE_FONTS = [
            'JetBrains Mono',
            'Fira Code',
            'Source Code Pro',
            'IBM Plex Mono',
            'Roboto Mono',
            'Space Mono',
            'Inconsolata',
            'Ubuntu Mono',
            'Courier Prime',
            'Anonymous Pro'
        ];

        const CONFIG = {
            canvasWidth: 600,
            canvasHeight: 600,
            textOffsetY: -35,      // vertical offset for text positioning
            text: 'WIAI25',
            fontSize: 320,
            fontFamily: 'IBM Plex Mono',
            // Outline visibility: hide from this level onwards (0 = never hide)
            outlineHideFromLevel: 0,
            // Two-line mode config
            twoLineEnabled: true,
            twoLineBreakpoint: 600, // px - below this width, use two-line layout
            twoLineWiaiSize: 200,   // font size for "WIAI"
            twoLine25Size: 380,     // font size for "25" (larger)
            twoLineGap: -65,        // vertical gap between lines
            // Fade limit for early levels (prevents complete fadeout)
            fadeLimitLevels: 9,     // apply fade limit to first N levels (0 = disabled)
            fadeLimitStep: 0.03,    // each level fades 3% less than max
            // Pixel size progression config
            maxPixelSize: 180,
            minPixelSize: 4,
            numLevels: 11,
            // Bezier curve for pixel size progression [x, y] where x=level progress(0-1), y=size progress(0-1, 0=max, 1=min)
            pixelSizeCurve: [[0, 0], [0.04, 0.69], [0.37, 1], [0.75, 0.8], [1, 1]],
            // Computed pixel sizes (will be calculated from curve)
            pixelSizes: [],
            pixelColor: '#facc15',
            pixelOpacity: 0.7,
            overlapThreshold: 0.25,
            bgColor: '#000000',
            // Bezier curve control points for fade [x, y] where x=progress(0-1), y=fade(0-1)
            fadeCurve: [[0, 0], [0.2, 0.5], [0.5, 0.7], [1, 0.9]],
            outlineStrokeWidth: 2,
            outlineColor: '#ffffff',
            // Shuffle vs Scanline
            shufflePixels: true,
            shuffleSeed: 42,
            // Fade mode - 'level' or 'pixel'
            fadeMode: 'pixel',
            fadeEveryNPixelsStart: 8,
            fadeEveryNPixelsEnd: 164,
            maxFadeStepsStart: 145,
            maxFadeStepsEnd: 695,
            // Pulse animation config
            pulseScalePixels: 4,  // absolute size change in pixels (0-10)
            pulseGlow: 0.8,       // glow/shadow intensity
            pulseBrightness: 0.5, // color brighten toward white (0 = none, 1 = full white)
            pulseFrequency: 0.2,  // speed of pulse oscillation
            pulseCurve: 'linear'  // 'linear', 'ease-in', 'ease-out', 'ease-in-out'
        };

        // Color presets
        const COLOR_PRESETS = {
            classic: { bg: '#f8f8f8', pixel: '#1a5f5f', outline: '#ffffff' },
            dark: { bg: '#1a1a1a', pixel: '#00ff88', outline: '#333333' },
            highcontrast: { bg: '#000000', pixel: '#facc15', outline: '#000000' },
            ocean: { bg: '#0a1628', pixel: '#4fc3f7', outline: '#0a1628' },
            sunset: { bg: '#2d1b33', pixel: '#ff6b6b', outline: '#2d1b33' }
        };

        // Pulsing effect state
        let pulsePhase = 0;
        let pulseAnimationId = null;

        // Calculate pixel sizes from bezier curve
        function calculatePixelSizesFromCurve() {
            const sizes = [];
            for (let i = 0; i < CONFIG.numLevels; i++) {
                const t = i / (CONFIG.numLevels - 1);
                const curveY = evaluateBezierCurve(CONFIG.pixelSizeCurve, t);
                // curveY 0 = maxPixelSize, curveY 1 = minPixelSize
                const size = Math.round(CONFIG.maxPixelSize - curveY * (CONFIG.maxPixelSize - CONFIG.minPixelSize));
                // Avoid duplicates - only add if different from last
                if (sizes.length === 0 || sizes[sizes.length - 1] !== size) {
                    sizes.push(size);
                }
            }
            // Ensure we always have at least min pixel at the end
            if (sizes[sizes.length - 1] !== CONFIG.minPixelSize) {
                sizes.push(CONFIG.minPixelSize);
            }
            CONFIG.pixelSizes = sizes;
            return sizes;
        }

        // State
        let frames = [];
        let framesTwoLine = []; // Two-line layout frames
        let levelStats = []; // Debug stats per level
        let levelStatsTwoLine = []; // Debug stats for two-line mode
        let currentFrame = 0;
        let isPlaying = false;
        let playInterval = null;
        const speeds = [0.25, 0.5, 1, 2, 4, 8];
        let speedIndex = 2;
        let currentLayoutMode = 'twoline'; // 'single' or 'twoline'

        // DOM Elements
        const displayCanvas = document.getElementById('display-canvas');
        const displayCtx = displayCanvas.getContext('2d');
        const slider = document.getElementById('frame-slider');
        const loading = document.getElementById('loading');
        const progressFill = document.getElementById('progress-fill');

        // Hidden canvas for text mask (single-line)
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = CONFIG.canvasWidth;
        maskCanvas.height = CONFIG.canvasHeight;
        const maskCtx = maskCanvas.getContext('2d');

        // Hidden canvas for two-line text mask
        const maskCanvasTwoLine = document.createElement('canvas');
        maskCanvasTwoLine.width = CONFIG.canvasWidth;
        maskCanvasTwoLine.height = CONFIG.canvasHeight;
        const maskCtxTwoLine = maskCanvasTwoLine.getContext('2d');

        // Update all canvas dimensions
        function updateCanvasDimensions() {
            displayCanvas.width = CONFIG.canvasWidth;
            displayCanvas.height = CONFIG.canvasHeight;
            maskCanvas.width = CONFIG.canvasWidth;
            maskCanvas.height = CONFIG.canvasHeight;
            maskCanvasTwoLine.width = CONFIG.canvasWidth;
            maskCanvasTwoLine.height = CONFIG.canvasHeight;
        }

        // Generate text mask (single-line: "WIAI25")
        function generateTextMask() {
            maskCtx.fillStyle = 'white';
            maskCtx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

            maskCtx.fillStyle = 'black';
            maskCtx.font = `700 ${CONFIG.fontSize}px "${CONFIG.fontFamily}"`;
            maskCtx.textAlign = 'center';
            maskCtx.textBaseline = 'middle';
            maskCtx.fillText(CONFIG.text, CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2 + CONFIG.textOffsetY);
        }

        // Generate two-line text mask ("WIAI" on top, "25" below, larger)
        function generateTextMaskTwoLine() {
            maskCtxTwoLine.fillStyle = 'white';
            maskCtxTwoLine.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

            maskCtxTwoLine.fillStyle = 'black';

            // Calculate vertical positions
            const wiaiSize = CONFIG.twoLineWiaiSize;
            const num25Size = CONFIG.twoLine25Size;
            const gap = CONFIG.twoLineGap;

            // Total height of both lines
            const totalHeight = wiaiSize + gap + num25Size;
            const startY = (CONFIG.canvasHeight - totalHeight) / 2 + CONFIG.textOffsetY;

            // Draw "WIAI" (smaller, top)
            maskCtxTwoLine.font = `700 ${wiaiSize}px "${CONFIG.fontFamily}"`;
            maskCtxTwoLine.textAlign = 'center';
            maskCtxTwoLine.textBaseline = 'top';
            maskCtxTwoLine.fillText('WIAI', CONFIG.canvasWidth / 2, startY);

            // Draw "25" (larger, bottom)
            maskCtxTwoLine.font = `700 ${num25Size}px "${CONFIG.fontFamily}"`;
            maskCtxTwoLine.textBaseline = 'top';
            maskCtxTwoLine.fillText('25', CONFIG.canvasWidth / 2, startY + wiaiSize + gap);
        }

        // Check overlap of a cell with the text mask (generic version)
        function getCellOverlapWithMask(x, y, size, ctx) {
            const imageData = ctx.getImageData(x, y, size, size);
            const pixels = imageData.data;
            let blackPixels = 0;
            const totalPixels = size * size;

            for (let i = 0; i < pixels.length; i += 4) {
                if (pixels[i] < 128) {
                    blackPixels++;
                }
            }

            return blackPixels / totalPixels;
        }

        // Check overlap of a cell with the text mask (single-line)
        function getCellOverlap(x, y, size) {
            const imageData = maskCtx.getImageData(x, y, size, size);
            const pixels = imageData.data;
            let blackPixels = 0;
            const totalPixels = size * size;

            for (let i = 0; i < pixels.length; i += 4) {
                if (pixels[i] < 128) {
                    blackPixels++;
                }
            }

            return blackPixels / totalPixels;
        }

        // Generate valid cells for a pixel size (generic version with mask ctx)
        function getValidCellsWithMask(pixelSize, maskCtxToUse) {
            const cells = [];
            const cols = Math.floor(CONFIG.canvasWidth / pixelSize);
            const rows = Math.floor(CONFIG.canvasHeight / pixelSize);

            const offsetX = (CONFIG.canvasWidth - cols * pixelSize) / 2;
            const offsetY = (CONFIG.canvasHeight - rows * pixelSize) / 2;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = Math.floor(offsetX + col * pixelSize);
                    const y = Math.floor(offsetY + row * pixelSize);
                    const overlap = getCellOverlapWithMask(x, y, pixelSize, maskCtxToUse);

                    if (overlap >= CONFIG.overlapThreshold) {
                        cells.push({ x, y, size: pixelSize, overlap });
                    }
                }
            }

            return cells;
        }

        // Generate valid cells for a pixel size (single-line)
        function getValidCells(pixelSize) {
            return getValidCellsWithMask(pixelSize, maskCtx);
        }

        // Generate valid cells for two-line layout
        function getValidCellsTwoLine(pixelSize) {
            return getValidCellsWithMask(pixelSize, maskCtxTwoLine);
        }

        // Seeded random number generator (Mulberry32)
        function seededRandom(seed) {
            return function() {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        // Fisher-Yates shuffle with seed
        function shuffleArray(array, seed) {
            const result = [...array];
            const rng = seededRandom(seed);
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        // Fade color toward background (smart direction based on bg color)
        function fadeColor(hexColor, bgColor, amount) {
            // Parse foreground color
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);

            // Parse background color
            const bgR = parseInt(bgColor.slice(1, 3), 16);
            const bgG = parseInt(bgColor.slice(3, 5), 16);
            const bgB = parseInt(bgColor.slice(5, 7), 16);

            // Interpolate toward background
            const newR = Math.round(r + (bgR - r) * amount);
            const newG = Math.round(g + (bgG - g) * amount);
            const newB = Math.round(b + (bgB - b) * amount);

            return `rgb(${newR}, ${newG}, ${newB})`;
        }

        // Store history as array of {cells, level}
        let historyLevels = [];
        let historyLevelsTwoLine = []; // For two-line mode
        // For pixel-wise fading: all pixels with their drawn frame index
        let allPixelsWithTiming = []; // [{x, y, size, drawnAtFrame}, ...]
        let allPixelsWithTimingTwoLine = []; // For two-line mode

        // Evaluate cubic bezier curve at t
        function evaluateBezierCurve(points, t) {
            // Interpolate through control points using De Casteljau's algorithm
            // For our use case: find y value for given x (level progress)
            // We'll sample the curve and interpolate
            const n = points.length - 1;
            let result = 0;
            for (let i = 0; i <= n; i++) {
                const binomial = factorial(n) / (factorial(i) * factorial(n - i));
                const basis = binomial * Math.pow(1 - t, n - i) * Math.pow(t, i);
                result += points[i][1] * basis;
            }
            return Math.max(0, Math.min(1, result));
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        // Get fade amount for a given level using the bezier curve (level-wise mode)
        function getFadeForLevel(historyLevel, currentLevel, totalLevels) {
            const levelsAgo = currentLevel - historyLevel;
            const maxLevelsAgo = totalLevels - 1;
            const t = Math.min(levelsAgo / maxLevelsAgo, 1);
            return evaluateBezierCurve(CONFIG.fadeCurve, t);
        }

        // Interpolate a value linearly based on progress (0-1)
        function interpolateValue(startVal, endVal, progress) {
            return startVal + (endVal - startVal) * progress;
        }

        // Get fade amount for a pixel based on when it was drawn (pixel-wise mode)
        function getFadeForPixel(drawnAtFrame, currentFrame, totalFrames) {
            // Interpolate fadeEveryNPixels and maxFadeSteps based on when pixel was DRAWN
            // This ensures each pixel has consistent fade parameters throughout its lifetime
            const drawProgress = totalFrames > 0 ? drawnAtFrame / totalFrames : 0;
            const fadeEveryN = Math.max(1, Math.round(interpolateValue(
                CONFIG.fadeEveryNPixelsStart,
                CONFIG.fadeEveryNPixelsEnd,
                drawProgress
            )));
            const maxFadeSteps = Math.max(1, Math.round(interpolateValue(
                CONFIG.maxFadeStepsStart,
                CONFIG.maxFadeStepsEnd,
                drawProgress
            )));

            const framesSince = currentFrame - drawnAtFrame;
            // How many "fade steps" have passed?
            const fadeSteps = Math.floor(framesSince / fadeEveryN);
            const t = Math.min(fadeSteps / maxFadeSteps, 1);
            return evaluateBezierCurve(CONFIG.fadeCurve, t);
        }

        // Get maximum fade amount for a level (early levels don't fade completely)
        function getMaxFadeForLevel(pixelLevel) {
            if (CONFIG.fadeLimitLevels === 0 || pixelLevel > CONFIG.fadeLimitLevels) {
                return 1.0; // No limit, can fade completely
            }
            // Level 1: max 98%, Level 2: max 96%, etc.
            return 1.0 - pixelLevel * CONFIG.fadeLimitStep;
        }

        // Render a frame (supports both single-line and two-line modes)
        function renderFrame(frameData, layoutMode = 'single') {
            const { index: frameIndex, level, currentPixels } = frameData;
            const totalLevels = CONFIG.pixelSizes.length;

            // Select data based on layout mode
            const isTwoLine = layoutMode === 'twoline';
            const pixelTiming = isTwoLine ? allPixelsWithTimingTwoLine : allPixelsWithTiming;
            const history = isTwoLine ? historyLevelsTwoLine : historyLevels;
            const totalFrames = isTwoLine ? framesTwoLine.length : frames.length;

            // Clear with background
            displayCtx.fillStyle = CONFIG.bgColor;
            displayCtx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

            if (CONFIG.fadeMode === 'pixel') {
                // PIXEL-WISE FADING: Each pixel fades based on when it was drawn
                for (let i = 0; i <= frameIndex && i < pixelTiming.length; i++) {
                    const pixel = pixelTiming[i];
                    const rawFadeAmount = getFadeForPixel(pixel.drawnAtFrame, frameIndex, totalFrames);
                    // Apply fade limit for early levels
                    const maxFade = getMaxFadeForLevel(pixel.level);
                    const fadeAmount = Math.min(rawFadeAmount, maxFade, 0.95);
                    const fadedColor = fadeColor(CONFIG.pixelColor, CONFIG.bgColor, fadeAmount);

                    displayCtx.fillStyle = fadedColor;
                    displayCtx.globalAlpha = CONFIG.pixelOpacity;
                    displayCtx.fillRect(pixel.x, pixel.y, pixel.size, pixel.size);
                }
            } else {
                // LEVEL-WISE FADING: Original behavior
                const completedLevels = history.filter(h => h.level < level);
                completedLevels.forEach(historyLevel => {
                    const rawFadeAmount = getFadeForLevel(historyLevel.level, level, totalLevels);
                    // Apply fade limit for early levels
                    const maxFade = getMaxFadeForLevel(historyLevel.level);
                    const fadeAmount = Math.min(rawFadeAmount, maxFade, 0.95);
                    const fadedColor = fadeColor(CONFIG.pixelColor, CONFIG.bgColor, fadeAmount);

                    displayCtx.fillStyle = fadedColor;
                    displayCtx.globalAlpha = CONFIG.pixelOpacity;
                    historyLevel.cells.forEach(cell => {
                        displayCtx.fillRect(cell.x, cell.y, cell.size, cell.size);
                    });
                });

                // Draw current level pixels (no fade)
                displayCtx.fillStyle = CONFIG.pixelColor;
                displayCtx.globalAlpha = CONFIG.pixelOpacity;
                currentPixels.forEach(cell => {
                    displayCtx.fillRect(cell.x, cell.y, cell.size, cell.size);
                });
            }

            // Highlight newest pixel with pulsing effect
            if (frameIndex >= 0 && frameIndex < pixelTiming.length) {
                const newestPixel = pixelTiming[frameIndex];

                const normalizedPhase = (Math.sin(pulsePhase) + 1) / 2;
                let easedPhase;
                switch (CONFIG.pulseCurve) {
                    case 'ease-in':
                        easedPhase = normalizedPhase * normalizedPhase;
                        break;
                    case 'ease-out':
                        easedPhase = 1 - (1 - normalizedPhase) * (1 - normalizedPhase);
                        break;
                    case 'ease-in-out':
                        easedPhase = normalizedPhase < 0.5
                            ? 2 * normalizedPhase * normalizedPhase
                            : 1 - Math.pow(-2 * normalizedPhase + 2, 2) / 2;
                        break;
                    default:
                        easedPhase = normalizedPhase;
                }

                // Absolute pixel size increase (same for all pixel sizes)
                const sizeIncrease = easedPhase * CONFIG.pulseScalePixels;
                const scaledSize = newestPixel.size + sizeIncrease;
                const offset = sizeIncrease / 2;

                const brightenAmount = easedPhase * CONFIG.pulseBrightness;
                const r = parseInt(CONFIG.pixelColor.slice(1, 3), 16);
                const g = parseInt(CONFIG.pixelColor.slice(3, 5), 16);
                const b = parseInt(CONFIG.pixelColor.slice(5, 7), 16);
                const brightR = Math.round(r + (255 - r) * brightenAmount);
                const brightG = Math.round(g + (255 - g) * brightenAmount);
                const brightB = Math.round(b + (255 - b) * brightenAmount);
                const brightColor = `rgb(${brightR}, ${brightG}, ${brightB})`;

                displayCtx.shadowColor = brightColor;
                displayCtx.shadowBlur = 5 + easedPhase * CONFIG.pulseGlow * 40;
                displayCtx.fillStyle = brightColor;
                displayCtx.globalAlpha = Math.min(1, CONFIG.pixelOpacity + 0.1 + easedPhase * CONFIG.pulseGlow * 0.4);

                displayCtx.fillRect(
                    newestPixel.x - offset,
                    newestPixel.y - offset,
                    scaledSize,
                    scaledSize
                );

                displayCtx.shadowBlur = 0;
            }

            // Draw outline (only if not hidden for this level)
            const shouldHideOutline = CONFIG.outlineHideFromLevel > 0 && level >= CONFIG.outlineHideFromLevel;
            if (!shouldHideOutline) {
                displayCtx.globalAlpha = 1;
                displayCtx.lineJoin = 'round';
                displayCtx.lineWidth = CONFIG.outlineStrokeWidth;
                displayCtx.strokeStyle = CONFIG.outlineColor;

                if (isTwoLine) {
                    // Two-line outline: "WIAI" on top, "25" below
                    const wiaiSize = CONFIG.twoLineWiaiSize;
                    const num25Size = CONFIG.twoLine25Size;
                    const gap = CONFIG.twoLineGap;
                    const totalHeight = wiaiSize + gap + num25Size;
                    const startY = (CONFIG.canvasHeight - totalHeight) / 2 + CONFIG.textOffsetY;

                    displayCtx.textAlign = 'center';

                    // Draw "WIAI" outline
                    displayCtx.font = `700 ${wiaiSize}px "${CONFIG.fontFamily}"`;
                    displayCtx.textBaseline = 'top';
                    displayCtx.strokeText('WIAI', CONFIG.canvasWidth / 2, startY);

                    // Draw "25" outline
                    displayCtx.font = `700 ${num25Size}px "${CONFIG.fontFamily}"`;
                    displayCtx.strokeText('25', CONFIG.canvasWidth / 2, startY + wiaiSize + gap);
                } else {
                    // Single-line outline: "WIAI25"
                    displayCtx.font = `700 ${CONFIG.fontSize}px "${CONFIG.fontFamily}"`;
                    displayCtx.textAlign = 'center';
                    displayCtx.textBaseline = 'middle';
                    displayCtx.strokeText(CONFIG.text, CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2 + CONFIG.textOffsetY);
                }
            }
        }

        // Update debug panel
        function updateDebugPanel(currentLevel) {
            const content = levelStats.map((stat, i) => {
                const isActive = i + 1 === currentLevel;
                return `
                    <div class="debug-level ${isActive ? 'active' : ''}">
                        <strong>Level ${i + 1}</strong> (${stat.pixelSize}px) |
                        Grid: ${stat.cols}×${stat.rows} = ${stat.totalCells} |
                        Gültig: ${stat.validCells} (${(stat.validCells / stat.totalCells * 100).toFixed(1)}%) |
                        Kumulativ: ${stat.cumulativeFrames}
                    </div>
                `;
            }).join('');
            document.getElementById('debug-content').innerHTML = content;
        }

        // Generate all frames
        async function generateFrames() {
            // Update canvas dimensions first
            updateCanvasDimensions();
            // Generate text masks for both layouts
            generateTextMask();
            generateTextMaskTwoLine();
            calculatePixelSizesFromCurve();

            // Reset state
            frames = [];
            framesTwoLine = [];
            levelStats = [];
            levelStatsTwoLine = [];
            historyLevels = [];
            historyLevelsTwoLine = [];
            allPixelsWithTiming = [];
            allPixelsWithTimingTwoLine = [];

            let frameIndex = 0;
            let frameIndexTwoLine = 0;
            let totalFrames = 0;
            let totalFramesTwoLine = 0;

            // First pass: count total frames and gather stats for BOTH layouts
            for (let level = 0; level < CONFIG.pixelSizes.length; level++) {
                const pixelSize = CONFIG.pixelSizes[level];
                const cols = Math.floor(CONFIG.canvasWidth / pixelSize);
                const rows = Math.floor(CONFIG.canvasHeight / pixelSize);

                // Single-line stats
                const cells = getValidCells(pixelSize);
                totalFrames += cells.length;
                levelStats.push({
                    level: level + 1,
                    pixelSize,
                    cols,
                    rows,
                    totalCells: cols * rows,
                    validCells: cells.length,
                    cumulativeFrames: totalFrames
                });

                // Two-line stats
                const cellsTwoLine = getValidCellsTwoLine(pixelSize);
                totalFramesTwoLine += cellsTwoLine.length;
                levelStatsTwoLine.push({
                    level: level + 1,
                    pixelSize,
                    cols,
                    rows,
                    totalCells: cols * rows,
                    validCells: cellsTwoLine.length,
                    cumulativeFrames: totalFramesTwoLine
                });
            }

            console.log('=== WIAI25 Scanline Debug ===');
            console.log('Single-line total frames:', totalFrames);
            console.log('Two-line total frames:', totalFramesTwoLine);
            console.table(levelStats);

            // Use single-line frame count for slider (they should be similar)
            document.getElementById('frame-total').textContent = totalFrames;
            slider.max = totalFrames - 1;

            // Calculate total for progress bar (both layouts)
            const totalForProgress = totalFrames + totalFramesTwoLine;
            let progressCount = 0;

            // Second pass: generate frames for SINGLE-LINE
            for (let level = 0; level < CONFIG.pixelSizes.length; level++) {
                const pixelSize = CONFIG.pixelSizes[level];
                let cells = getValidCells(pixelSize);

                if (CONFIG.shufflePixels) {
                    cells = shuffleArray(cells, CONFIG.shuffleSeed + level);
                }

                for (let i = 0; i < cells.length; i++) {
                    const currentPixels = cells.slice(0, i + 1);

                    allPixelsWithTiming.push({
                        ...cells[i],
                        drawnAtFrame: frameIndex,
                        level: level + 1
                    });

                    frames.push({
                        index: frameIndex,
                        level: level + 1,
                        pixelSize: pixelSize,
                        cellsInLevel: cells.length,
                        cellIndex: i + 1,
                        currentPixels: currentPixels
                    });

                    frameIndex++;
                    progressCount++;

                    const progress = (progressCount / totalForProgress) * 100;
                    progressFill.style.width = `${progress}%`;

                    if (frameIndex % 50 === 0) {
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                historyLevels.push({
                    level: level + 1,
                    cells: cells
                });

                console.log(`Single-line Level ${level + 1} complete: ${cells.length} cells`);
            }

            // Third pass: generate frames for TWO-LINE
            for (let level = 0; level < CONFIG.pixelSizes.length; level++) {
                const pixelSize = CONFIG.pixelSizes[level];
                let cells = getValidCellsTwoLine(pixelSize);

                if (CONFIG.shufflePixels) {
                    cells = shuffleArray(cells, CONFIG.shuffleSeed + level + 1000); // Different seed
                }

                for (let i = 0; i < cells.length; i++) {
                    const currentPixels = cells.slice(0, i + 1);

                    allPixelsWithTimingTwoLine.push({
                        ...cells[i],
                        drawnAtFrame: frameIndexTwoLine,
                        level: level + 1
                    });

                    framesTwoLine.push({
                        index: frameIndexTwoLine,
                        level: level + 1,
                        pixelSize: pixelSize,
                        cellsInLevel: cells.length,
                        cellIndex: i + 1,
                        currentPixels: currentPixels
                    });

                    frameIndexTwoLine++;
                    progressCount++;

                    const progress = (progressCount / totalForProgress) * 100;
                    progressFill.style.width = `${progress}%`;

                    if (frameIndexTwoLine % 50 === 0) {
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                historyLevelsTwoLine.push({
                    level: level + 1,
                    cells: cells
                });

                console.log(`Two-line Level ${level + 1} complete: ${cells.length} cells`);
            }

            loading.classList.add('hidden');
            updateDebugPanel(1);
            showFrame(0);
        }

        // Show a specific frame
        function showFrame(index) {
            // Select frame array based on layout mode
            const frameArray = currentLayoutMode === 'twoline' ? framesTwoLine : frames;
            const statsArray = currentLayoutMode === 'twoline' ? levelStatsTwoLine : levelStats;

            if (index < 0 || index >= frameArray.length) return;

            currentFrame = index;
            const frame = frameArray[index];

            renderFrame(frame, currentLayoutMode);

            // Update stats
            document.getElementById('frame-num').textContent = frame.index + 1;
            document.getElementById('level-num').textContent = frame.level;
            document.getElementById('pixel-size').textContent = frame.pixelSize;
            document.getElementById('cells-in-level').textContent = `${frame.cellIndex}/${frame.cellsInLevel}`;

            // Update frame total for current mode
            document.getElementById('frame-total').textContent = frameArray.length;

            // Show interpolated values in pixel mode
            const interpolatedDiv = document.getElementById('interpolated-values');
            if (CONFIG.fadeMode === 'pixel') {
                const progress = frameArray.length > 0 ? index / frameArray.length : 0;
                const currentFadeN = Math.max(1, Math.round(interpolateValue(
                    CONFIG.fadeEveryNPixelsStart,
                    CONFIG.fadeEveryNPixelsEnd,
                    progress
                )));
                const currentMaxSteps = Math.max(1, Math.round(interpolateValue(
                    CONFIG.maxFadeStepsStart,
                    CONFIG.maxFadeStepsEnd,
                    progress
                )));
                document.getElementById('current-fade-n').textContent = currentFadeN;
                document.getElementById('current-max-steps').textContent = currentMaxSteps;
                interpolatedDiv.style.display = 'flex';
            } else {
                interpolatedDiv.style.display = 'none';
            }

            // Update slider max for current mode
            slider.max = frameArray.length - 1;
            slider.value = index;
            updateDebugPanel(frame.level);
        }

        // Switch layout mode
        function setLayoutMode(mode) {
            if (mode !== currentLayoutMode) {
                const oldFrameArray = currentLayoutMode === 'twoline' ? framesTwoLine : frames;
                const newFrameArray = mode === 'twoline' ? framesTwoLine : frames;

                // Map current frame to equivalent position in new mode
                const progress = oldFrameArray.length > 0 ? currentFrame / oldFrameArray.length : 0;
                const newIndex = Math.min(Math.floor(progress * newFrameArray.length), newFrameArray.length - 1);

                currentLayoutMode = mode;
                showFrame(Math.max(0, newIndex));
            }
        }

        // Play controls
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').textContent = isPlaying ? 'Pause' : 'Play';

            if (isPlaying) {
                const interval = 100 / speeds[speedIndex];
                playInterval = setInterval(() => {
                    const frameArray = currentLayoutMode === 'twoline' ? framesTwoLine : frames;
                    if (currentFrame < frameArray.length - 1) {
                        showFrame(currentFrame + 1);
                    } else {
                        togglePlay();
                    }
                }, interval);
            } else {
                clearInterval(playInterval);
            }
        }

        function updateSpeed() {
            document.getElementById('speed-display').textContent = `${speeds[speedIndex]}x`;
            if (isPlaying) {
                clearInterval(playInterval);
                const interval = 100 / speeds[speedIndex];
                playInterval = setInterval(() => {
                    const frameArray = currentLayoutMode === 'twoline' ? framesTwoLine : frames;
                    if (currentFrame < frameArray.length - 1) {
                        showFrame(currentFrame + 1);
                    } else {
                        togglePlay();
                    }
                }, interval);
            }
        }

        // Event listeners
        slider.addEventListener('input', (e) => {
            showFrame(parseInt(e.target.value));
        });

        document.getElementById('play-btn').addEventListener('click', togglePlay);

        document.getElementById('slower-btn').addEventListener('click', () => {
            if (speedIndex > 0) {
                speedIndex--;
                updateSpeed();
            }
        });

        document.getElementById('faster-btn').addEventListener('click', () => {
            if (speedIndex < speeds.length - 1) {
                speedIndex++;
                updateSpeed();
            }
        });

        // Layout toggle button
        const layoutToggleBtn = document.getElementById('layout-toggle-btn');
        layoutToggleBtn.addEventListener('click', () => {
            const newMode = currentLayoutMode === 'single' ? 'twoline' : 'single';
            setLayoutMode(newMode);
            layoutToggleBtn.textContent = newMode === 'single' ? 'Two-Line (T)' : 'Single-Line (T)';
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            const frameArray = currentLayoutMode === 'twoline' ? framesTwoLine : frames;
            if (e.key === 'ArrowRight') {
                showFrame(Math.min(currentFrame + 1, frameArray.length - 1));
            } else if (e.key === 'ArrowLeft') {
                showFrame(Math.max(currentFrame - 1, 0));
            } else if (e.key === ' ') {
                e.preventDefault();
                togglePlay();
            } else if (e.key === 't' || e.key === 'T') {
                // Toggle layout mode with 't' key
                const newMode = currentLayoutMode === 'single' ? 'twoline' : 'single';
                setLayoutMode(newMode);
                layoutToggleBtn.textContent = newMode === 'single' ? 'Two-Line (T)' : 'Single-Line (T)';
            }
        });

        // Tuning controls
        const tuneOpacity = document.getElementById('tune-opacity');
        const tuneOverlap = document.getElementById('tune-overlap');
        const tuneStroke = document.getElementById('tune-stroke');
        const tuneOutlineColor = document.getElementById('tune-outline-color');
        const tuneOrder = document.getElementById('tune-order');
        const tuneFadeMode = document.getElementById('tune-fade-mode');
        const tuneFadeNStart = document.getElementById('tune-fade-n-start');
        const tuneFadeNEnd = document.getElementById('tune-fade-n-end');
        const tuneMaxFadeStart = document.getElementById('tune-max-fade-start');
        const tuneMaxFadeEnd = document.getElementById('tune-max-fade-end');
        const fadeNStartContainer = document.getElementById('fade-n-start-container');
        const fadeNEndContainer = document.getElementById('fade-n-end-container');
        const maxFadeStartContainer = document.getElementById('max-fade-start-container');
        const maxFadeEndContainer = document.getElementById('max-fade-end-container');
        const exportField = document.getElementById('export-field');

        // Pixel size curve controls
        const tuneMaxPixel = document.getElementById('tune-max-pixel');
        const tuneMinPixel = document.getElementById('tune-min-pixel');
        const tuneNumLevels = document.getElementById('tune-num-levels');

        // Color controls
        const tunePreset = document.getElementById('tune-preset');
        const tuneBgColor = document.getElementById('tune-bg-color');
        const tuneBgColorText = document.getElementById('tune-bg-color-text');
        const tunePixelColor = document.getElementById('tune-pixel-color');
        const tunePixelColorText = document.getElementById('tune-pixel-color-text');

        // Pulse controls
        const tunePulseScale = document.getElementById('tune-pulse-scale');
        const tunePulseGlow = document.getElementById('tune-pulse-glow');
        const tunePulseBrightness = document.getElementById('tune-pulse-brightness');
        const tunePulseFrequency = document.getElementById('tune-pulse-frequency');
        const tunePulseCurve = document.getElementById('tune-pulse-curve');

        // New controls: Font, Outline hide, Two-line layout
        const tuneFont = document.getElementById('tune-font');
        const tuneOutlineHide = document.getElementById('tune-outline-hide');
        const tuneTwolineBreakpoint = document.getElementById('tune-twoline-breakpoint');
        const tuneSinglelineFontsize = document.getElementById('tune-singleline-fontsize');
        const tuneTwolineWiai = document.getElementById('tune-twoline-wiai');
        const tuneTwoline25 = document.getElementById('tune-twoline-25');
        const tuneTwolineGap = document.getElementById('tune-twoline-gap');
        // Fade limit controls
        const tuneFadeLimitLevels = document.getElementById('tune-fade-limit-levels');
        const tuneFadeLimitStep = document.getElementById('tune-fade-limit-step');
        // Canvas dimension controls
        const tuneCanvasWidth = document.getElementById('tune-canvas-width');
        const tuneCanvasHeight = document.getElementById('tune-canvas-height');
        const tuneTextOffsetY = document.getElementById('tune-text-offset-y');

        // Curve editor (fade)
        const curveCanvas = document.getElementById('curve-canvas');
        const curveCtx = curveCanvas.getContext('2d');
        const CURVE_PADDING = 20;
        let dragPointIndex = -1;

        // Pixel size curve editor
        const pixelCurveCanvas = document.getElementById('pixel-curve-canvas');
        const pixelCurveCtx = pixelCurveCanvas.getContext('2d');
        let pixelDragPointIndex = -1;

        function drawCurveEditor() {
            const w = curveCanvas.width;
            const h = curveCanvas.height;
            const plotW = w - CURVE_PADDING * 2;
            const plotH = h - CURVE_PADDING * 2;

            curveCtx.clearRect(0, 0, w, h);

            // Draw grid
            curveCtx.strokeStyle = '#ddd';
            curveCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const x = CURVE_PADDING + (plotW * i / 4);
                const y = CURVE_PADDING + (plotH * i / 4);
                curveCtx.beginPath();
                curveCtx.moveTo(x, CURVE_PADDING);
                curveCtx.lineTo(x, h - CURVE_PADDING);
                curveCtx.stroke();
                curveCtx.beginPath();
                curveCtx.moveTo(CURVE_PADDING, y);
                curveCtx.lineTo(w - CURVE_PADDING, y);
                curveCtx.stroke();
            }

            // Draw curve
            curveCtx.strokeStyle = CONFIG.pixelColor;
            curveCtx.lineWidth = 2;
            curveCtx.beginPath();
            for (let t = 0; t <= 1; t += 0.01) {
                const y = evaluateBezierCurve(CONFIG.fadeCurve, t);
                const px = CURVE_PADDING + t * plotW;
                const py = h - CURVE_PADDING - y * plotH;
                if (t === 0) curveCtx.moveTo(px, py);
                else curveCtx.lineTo(px, py);
            }
            curveCtx.stroke();

            // Draw control points
            CONFIG.fadeCurve.forEach((point, i) => {
                const px = CURVE_PADDING + point[0] * plotW;
                const py = h - CURVE_PADDING - point[1] * plotH;

                curveCtx.fillStyle = i === dragPointIndex ? '#ff6600' : CONFIG.pixelColor;
                curveCtx.beginPath();
                curveCtx.arc(px, py, 8, 0, Math.PI * 2);
                curveCtx.fill();

                curveCtx.fillStyle = '#fff';
                curveCtx.beginPath();
                curveCtx.arc(px, py, 4, 0, Math.PI * 2);
                curveCtx.fill();
            });
        }

        function getCurvePoint(e) {
            const rect = curveCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const w = curveCanvas.width;
            const h = curveCanvas.height;
            const plotW = w - CURVE_PADDING * 2;
            const plotH = h - CURVE_PADDING * 2;

            const normalX = Math.max(0, Math.min(1, (x - CURVE_PADDING) / plotW));
            const normalY = Math.max(0, Math.min(1, 1 - (y - CURVE_PADDING) / plotH));
            return [normalX, normalY];
        }

        function findNearestPoint(e) {
            const [mx, my] = getCurvePoint(e);
            let nearest = -1;
            let minDist = 0.1; // threshold

            CONFIG.fadeCurve.forEach((point, i) => {
                const dist = Math.sqrt(Math.pow(point[0] - mx, 2) + Math.pow(point[1] - my, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = i;
                }
            });
            return nearest;
        }

        curveCanvas.addEventListener('mousedown', (e) => {
            dragPointIndex = findNearestPoint(e);
            if (dragPointIndex >= 0) {
                drawCurveEditor();
            }
        });

        curveCanvas.addEventListener('mousemove', (e) => {
            if (dragPointIndex >= 0) {
                const [x, y] = getCurvePoint(e);
                // First and last points: only allow Y movement
                if (dragPointIndex === 0) {
                    CONFIG.fadeCurve[0] = [0, y];
                } else if (dragPointIndex === CONFIG.fadeCurve.length - 1) {
                    CONFIG.fadeCurve[dragPointIndex] = [1, y];
                } else {
                    CONFIG.fadeCurve[dragPointIndex] = [x, y];
                }
                drawCurveEditor();
                updateExportField();
                // Live preview
                if (frames.length > 0) {
                    showFrame(currentFrame);
                }
            }
        });

        curveCanvas.addEventListener('mouseup', () => {
            dragPointIndex = -1;
            drawCurveEditor();
        });

        curveCanvas.addEventListener('mouseleave', () => {
            if (dragPointIndex >= 0) {
                dragPointIndex = -1;
                drawCurveEditor();
            }
        });

        // Pixel size curve editor functions
        function drawPixelCurveEditor() {
            const w = pixelCurveCanvas.width;
            const h = pixelCurveCanvas.height;
            const plotW = w - CURVE_PADDING * 2;
            const plotH = h - CURVE_PADDING * 2;

            pixelCurveCtx.clearRect(0, 0, w, h);

            // Draw grid
            pixelCurveCtx.strokeStyle = '#ddd';
            pixelCurveCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const x = CURVE_PADDING + (plotW * i / 4);
                const y = CURVE_PADDING + (plotH * i / 4);
                pixelCurveCtx.beginPath();
                pixelCurveCtx.moveTo(x, CURVE_PADDING);
                pixelCurveCtx.lineTo(x, h - CURVE_PADDING);
                pixelCurveCtx.stroke();
                pixelCurveCtx.beginPath();
                pixelCurveCtx.moveTo(CURVE_PADDING, y);
                pixelCurveCtx.lineTo(w - CURVE_PADDING, y);
                pixelCurveCtx.stroke();
            }

            // Draw axis labels
            pixelCurveCtx.fillStyle = '#999';
            pixelCurveCtx.font = '10px system-ui';
            pixelCurveCtx.textAlign = 'right';
            pixelCurveCtx.fillText(`${CONFIG.maxPixelSize}px`, CURVE_PADDING - 4, h - CURVE_PADDING + 4);
            pixelCurveCtx.fillText(`${CONFIG.minPixelSize}px`, CURVE_PADDING - 4, CURVE_PADDING + 4);

            // Draw curve
            pixelCurveCtx.strokeStyle = '#cc6600';
            pixelCurveCtx.lineWidth = 2;
            pixelCurveCtx.beginPath();
            for (let t = 0; t <= 1; t += 0.01) {
                const curveY = evaluateBezierCurve(CONFIG.pixelSizeCurve, t);
                const px = CURVE_PADDING + t * plotW;
                // curveY=0 means maxPixel (bottom), curveY=1 means minPixel (top)
                const py = h - CURVE_PADDING - curveY * plotH;
                if (t === 0) pixelCurveCtx.moveTo(px, py);
                else pixelCurveCtx.lineTo(px, py);
            }
            pixelCurveCtx.stroke();

            // Draw sampled level points
            pixelCurveCtx.fillStyle = 'rgba(204, 102, 0, 0.3)';
            for (let i = 0; i < CONFIG.numLevels; i++) {
                const t = i / (CONFIG.numLevels - 1);
                const curveY = evaluateBezierCurve(CONFIG.pixelSizeCurve, t);
                const px = CURVE_PADDING + t * plotW;
                const py = h - CURVE_PADDING - curveY * plotH;
                pixelCurveCtx.beginPath();
                pixelCurveCtx.arc(px, py, 3, 0, Math.PI * 2);
                pixelCurveCtx.fill();
            }

            // Draw control points
            CONFIG.pixelSizeCurve.forEach((point, i) => {
                const px = CURVE_PADDING + point[0] * plotW;
                const py = h - CURVE_PADDING - point[1] * plotH;

                pixelCurveCtx.fillStyle = i === pixelDragPointIndex ? '#ff6600' : '#cc6600';
                pixelCurveCtx.beginPath();
                pixelCurveCtx.arc(px, py, 8, 0, Math.PI * 2);
                pixelCurveCtx.fill();

                pixelCurveCtx.fillStyle = '#fff';
                pixelCurveCtx.beginPath();
                pixelCurveCtx.arc(px, py, 4, 0, Math.PI * 2);
                pixelCurveCtx.fill();
            });

            // Update preview
            updatePixelSizesPreview();
        }

        function updatePixelSizesPreview() {
            const sizes = [];
            for (let i = 0; i < CONFIG.numLevels; i++) {
                const t = i / (CONFIG.numLevels - 1);
                const curveY = evaluateBezierCurve(CONFIG.pixelSizeCurve, t);
                const size = Math.round(CONFIG.maxPixelSize - curveY * (CONFIG.maxPixelSize - CONFIG.minPixelSize));
                if (sizes.length === 0 || sizes[sizes.length - 1] !== size) {
                    sizes.push(size);
                }
            }
            if (sizes[sizes.length - 1] !== CONFIG.minPixelSize) {
                sizes.push(CONFIG.minPixelSize);
            }
            document.getElementById('pixel-sizes-preview').textContent =
                `${sizes.length} Level: [${sizes.join(', ')}]`;
        }

        function getPixelCurvePoint(e) {
            const rect = pixelCurveCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const w = pixelCurveCanvas.width;
            const h = pixelCurveCanvas.height;
            const plotW = w - CURVE_PADDING * 2;
            const plotH = h - CURVE_PADDING * 2;

            const normalX = Math.max(0, Math.min(1, (x - CURVE_PADDING) / plotW));
            // Y: top = 1 (minPixel), bottom = 0 (maxPixel)
            const normalY = Math.max(0, Math.min(1, 1 - (y - CURVE_PADDING) / plotH));
            return [normalX, normalY];
        }

        function findNearestPixelCurvePoint(e) {
            const [mx, my] = getPixelCurvePoint(e);
            let nearest = -1;
            let minDist = 0.1;

            CONFIG.pixelSizeCurve.forEach((point, i) => {
                const dist = Math.sqrt(Math.pow(point[0] - mx, 2) + Math.pow(point[1] - my, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = i;
                }
            });
            return nearest;
        }

        pixelCurveCanvas.addEventListener('mousedown', (e) => {
            pixelDragPointIndex = findNearestPixelCurvePoint(e);
            if (pixelDragPointIndex >= 0) {
                drawPixelCurveEditor();
            }
        });

        pixelCurveCanvas.addEventListener('mousemove', (e) => {
            if (pixelDragPointIndex >= 0) {
                const [x, y] = getPixelCurvePoint(e);
                // First and last points: only allow Y movement
                if (pixelDragPointIndex === 0) {
                    CONFIG.pixelSizeCurve[0] = [0, y];
                } else if (pixelDragPointIndex === CONFIG.pixelSizeCurve.length - 1) {
                    CONFIG.pixelSizeCurve[pixelDragPointIndex] = [1, y];
                } else {
                    CONFIG.pixelSizeCurve[pixelDragPointIndex] = [x, y];
                }
                drawPixelCurveEditor();
                updateExportField();
            }
        });

        pixelCurveCanvas.addEventListener('mouseup', () => {
            pixelDragPointIndex = -1;
            drawPixelCurveEditor();
        });

        pixelCurveCanvas.addEventListener('mouseleave', () => {
            if (pixelDragPointIndex >= 0) {
                pixelDragPointIndex = -1;
                drawPixelCurveEditor();
            }
        });

        // Pixel size slider event listeners
        tuneMaxPixel.addEventListener('input', () => {
            CONFIG.maxPixelSize = parseInt(tuneMaxPixel.value);
            document.getElementById('tune-max-pixel-val').textContent = `${CONFIG.maxPixelSize}px`;
            drawPixelCurveEditor();
            updateExportField();
        });

        tuneMinPixel.addEventListener('input', () => {
            CONFIG.minPixelSize = parseInt(tuneMinPixel.value);
            document.getElementById('tune-min-pixel-val').textContent = `${CONFIG.minPixelSize}px`;
            drawPixelCurveEditor();
            updateExportField();
        });

        tuneNumLevels.addEventListener('input', () => {
            CONFIG.numLevels = parseInt(tuneNumLevels.value);
            document.getElementById('tune-num-levels-val').textContent = CONFIG.numLevels;
            drawPixelCurveEditor();
            updateExportField();
        });

        function updateExportField() {
            const params = {
                bgColor: CONFIG.bgColor,
                pixelColor: CONFIG.pixelColor,
                pixelOpacity: parseFloat(tuneOpacity.value),
                fadeCurve: CONFIG.fadeCurve.map(p => [Math.round(p[0] * 100) / 100, Math.round(p[1] * 100) / 100]),
                pixelSizeCurve: CONFIG.pixelSizeCurve.map(p => [Math.round(p[0] * 100) / 100, Math.round(p[1] * 100) / 100]),
                maxPixelSize: CONFIG.maxPixelSize,
                minPixelSize: CONFIG.minPixelSize,
                numLevels: CONFIG.numLevels,
                overlapThreshold: parseFloat(tuneOverlap.value),
                outlineStrokeWidth: parseInt(tuneStroke.value),
                outlineColor: CONFIG.outlineColor,
                shufflePixels: CONFIG.shufflePixels,
                fadeMode: CONFIG.fadeMode,
                fadeEveryNPixelsStart: CONFIG.fadeEveryNPixelsStart,
                fadeEveryNPixelsEnd: CONFIG.fadeEveryNPixelsEnd,
                maxFadeStepsStart: CONFIG.maxFadeStepsStart,
                maxFadeStepsEnd: CONFIG.maxFadeStepsEnd,
                pulseScalePixels: CONFIG.pulseScalePixels,
                pulseGlow: CONFIG.pulseGlow,
                pulseBrightness: CONFIG.pulseBrightness,
                pulseFrequency: CONFIG.pulseFrequency,
                pulseCurve: CONFIG.pulseCurve,
                // New parameters
                fontFamily: CONFIG.fontFamily,
                outlineHideFromLevel: CONFIG.outlineHideFromLevel,
                twoLineBreakpoint: CONFIG.twoLineBreakpoint,
                twoLineWiaiSize: CONFIG.twoLineWiaiSize,
                twoLine25Size: CONFIG.twoLine25Size,
                twoLineGap: CONFIG.twoLineGap,
                fadeLimitLevels: CONFIG.fadeLimitLevels,
                fadeLimitStep: CONFIG.fadeLimitStep,
                canvasWidth: CONFIG.canvasWidth,
                canvasHeight: CONFIG.canvasHeight,
                textOffsetY: CONFIG.textOffsetY
            };
            exportField.value = JSON.stringify(params);
        }

        // ========== FRAME EXPORT FOR DEPLOYMENT ==========

        // Format bytes to human-readable string
        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Build complete export data structure for viewer
        function buildFrameExportData() {
            return {
                version: "1.0.0",
                exportedAt: new Date().toISOString(),
                config: {
                    canvasWidth: CONFIG.canvasWidth,
                    canvasHeight: CONFIG.canvasHeight,
                    textOffsetY: CONFIG.textOffsetY,
                    text: CONFIG.text,
                    fontSize: CONFIG.fontSize,
                    fontFamily: CONFIG.fontFamily,
                    outlineHideFromLevel: CONFIG.outlineHideFromLevel,
                    twoLineEnabled: CONFIG.twoLineEnabled,
                    twoLineBreakpoint: CONFIG.twoLineBreakpoint,
                    twoLineWiaiSize: CONFIG.twoLineWiaiSize,
                    twoLine25Size: CONFIG.twoLine25Size,
                    twoLineGap: CONFIG.twoLineGap,
                    fadeLimitLevels: CONFIG.fadeLimitLevels,
                    fadeLimitStep: CONFIG.fadeLimitStep,
                    maxPixelSize: CONFIG.maxPixelSize,
                    minPixelSize: CONFIG.minPixelSize,
                    numLevels: CONFIG.numLevels,
                    pixelSizeCurve: CONFIG.pixelSizeCurve,
                    pixelSizes: CONFIG.pixelSizes,
                    pixelColor: CONFIG.pixelColor,
                    pixelOpacity: CONFIG.pixelOpacity,
                    overlapThreshold: CONFIG.overlapThreshold,
                    bgColor: CONFIG.bgColor,
                    fadeCurve: CONFIG.fadeCurve,
                    outlineStrokeWidth: CONFIG.outlineStrokeWidth,
                    outlineColor: CONFIG.outlineColor,
                    shufflePixels: CONFIG.shufflePixels,
                    shuffleSeed: CONFIG.shuffleSeed,
                    fadeMode: CONFIG.fadeMode,
                    fadeEveryNPixelsStart: CONFIG.fadeEveryNPixelsStart,
                    fadeEveryNPixelsEnd: CONFIG.fadeEveryNPixelsEnd,
                    maxFadeStepsStart: CONFIG.maxFadeStepsStart,
                    maxFadeStepsEnd: CONFIG.maxFadeStepsEnd,
                    pulseScalePixels: CONFIG.pulseScalePixels,
                    pulseGlow: CONFIG.pulseGlow,
                    pulseBrightness: CONFIG.pulseBrightness,
                    pulseFrequency: CONFIG.pulseFrequency,
                    pulseCurve: CONFIG.pulseCurve
                },
                metadata: {
                    singleLine: {
                        totalFrames: frames.length,
                        totalPixels: allPixelsWithTiming.length
                    },
                    twoLine: {
                        totalFrames: framesTwoLine.length,
                        totalPixels: allPixelsWithTimingTwoLine.length
                    }
                },
                frames: {
                    singleLine: allPixelsWithTiming,
                    twoLine: allPixelsWithTimingTwoLine
                }
            };
        }

        // Download file helper
        function downloadFile(content, filename, mimeType = 'application/json') {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Update file size estimate display
        function updateFrameExportSizeEstimate() {
            const sizeDisplay = document.getElementById('export-size-estimate');
            if (allPixelsWithTiming.length === 0) {
                sizeDisplay.textContent = '(keine Frames)';
                return;
            }

            const compress = document.getElementById('compress-export').checked;
            const data = buildFrameExportData();
            const jsonString = JSON.stringify(data);
            const uncompressedSize = new Blob([jsonString]).size;

            if (compress && typeof LZString !== 'undefined') {
                const compressed = LZString.compressToBase64(jsonString);
                const compressedSize = new Blob([compressed]).size;
                const ratio = Math.round((1 - compressedSize / uncompressedSize) * 100);
                sizeDisplay.textContent = `~${formatBytes(compressedSize)} (${ratio}% kleiner)`;
            } else {
                sizeDisplay.textContent = `~${formatBytes(uncompressedSize)}`;
            }
        }

        // Main export function
        function exportFramesToFile() {
            if (allPixelsWithTiming.length === 0) {
                alert('Keine Frames verfügbar. Bitte erst "Regenerate Frames" klicken.');
                return;
            }

            const compress = document.getElementById('compress-export').checked;
            const data = buildFrameExportData();
            const jsonString = JSON.stringify(data);

            let finalContent = jsonString;
            let filename = `wiai25-frames-${Date.now()}.json`;

            if (compress && typeof LZString !== 'undefined') {
                finalContent = LZString.compressToBase64(jsonString);
                filename = `wiai25-frames-${Date.now()}.lz.json`;
            }

            downloadFile(finalContent, filename);
            console.log(`Export: ${filename} (${formatBytes(new Blob([finalContent]).size)})`);
        }

        // ========== END FRAME EXPORT ==========

        function updateTuningDisplay() {
            document.getElementById('tune-opacity-val').textContent = tuneOpacity.value;
            document.getElementById('tune-overlap-val').textContent = tuneOverlap.value;
            document.getElementById('tune-stroke-val').textContent = tuneStroke.value;
            document.getElementById('tune-fade-n-start-val').textContent = tuneFadeNStart.value;
            document.getElementById('tune-fade-n-end-val').textContent = tuneFadeNEnd.value;
            document.getElementById('tune-max-fade-start-val').textContent = tuneMaxFadeStart.value;
            document.getElementById('tune-max-fade-end-val').textContent = tuneMaxFadeEnd.value;
            // Show/hide pixel-mode sliders based on mode
            const isPixelMode = CONFIG.fadeMode === 'pixel';
            fadeNStartContainer.style.display = isPixelMode ? 'flex' : 'none';
            fadeNEndContainer.style.display = isPixelMode ? 'flex' : 'none';
            maxFadeStartContainer.style.display = isPixelMode ? 'flex' : 'none';
            maxFadeEndContainer.style.display = isPixelMode ? 'flex' : 'none';
            updateExportField();
            drawCurveEditor();
            drawPixelCurveEditor();
        }

        // Live update for stroke width (doesn't need regeneration)
        tuneStroke.addEventListener('input', () => {
            CONFIG.outlineStrokeWidth = parseInt(tuneStroke.value);
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Live update for outline color
        tuneOutlineColor.addEventListener('change', () => {
            CONFIG.outlineColor = tuneOutlineColor.value;
            updateExportField();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Live update for opacity (doesn't need regeneration for current frame)
        tuneOpacity.addEventListener('input', () => {
            CONFIG.pixelOpacity = parseFloat(tuneOpacity.value);
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // These need regeneration
        tuneOverlap.addEventListener('input', updateTuningDisplay);

        // Order toggle (needs regeneration)
        tuneOrder.addEventListener('change', () => {
            CONFIG.shufflePixels = tuneOrder.value === 'shuffle';
            updateExportField();
        });

        // Fade mode toggle (live update)
        tuneFadeMode.addEventListener('change', () => {
            CONFIG.fadeMode = tuneFadeMode.value;
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Fade N sliders (live update)
        tuneFadeNStart.addEventListener('input', () => {
            CONFIG.fadeEveryNPixelsStart = parseInt(tuneFadeNStart.value);
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        tuneFadeNEnd.addEventListener('input', () => {
            CONFIG.fadeEveryNPixelsEnd = parseInt(tuneFadeNEnd.value);
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Max fade steps sliders (live update)
        tuneMaxFadeStart.addEventListener('input', () => {
            CONFIG.maxFadeStepsStart = parseInt(tuneMaxFadeStart.value);
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        tuneMaxFadeEnd.addEventListener('input', () => {
            CONFIG.maxFadeStepsEnd = parseInt(tuneMaxFadeEnd.value);
            updateTuningDisplay();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Color preset handler
        tunePreset.addEventListener('change', () => {
            const preset = tunePreset.value;
            if (preset !== 'custom' && COLOR_PRESETS[preset]) {
                const colors = COLOR_PRESETS[preset];
                CONFIG.bgColor = colors.bg;
                CONFIG.pixelColor = colors.pixel;
                CONFIG.outlineColor = colors.outline;
                // Update UI
                tuneBgColor.value = colors.bg;
                tuneBgColorText.value = colors.bg;
                tunePixelColor.value = colors.pixel;
                tunePixelColorText.value = colors.pixel;
                tuneOutlineColor.value = colors.outline;
                updateExportField();
                if (frames.length > 0) {
                    showFrame(currentFrame);
                }
            }
        });

        // Background color handlers
        tuneBgColor.addEventListener('input', () => {
            CONFIG.bgColor = tuneBgColor.value;
            tuneBgColorText.value = tuneBgColor.value;
            tunePreset.value = 'custom';
            updateExportField();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        tuneBgColorText.addEventListener('input', () => {
            const val = tuneBgColorText.value;
            if (/^#[0-9A-Fa-f]{6}$/.test(val)) {
                CONFIG.bgColor = val;
                tuneBgColor.value = val;
                tunePreset.value = 'custom';
                updateExportField();
                if (frames.length > 0) {
                    showFrame(currentFrame);
                }
            }
        });

        // Pixel color handlers
        tunePixelColor.addEventListener('input', () => {
            CONFIG.pixelColor = tunePixelColor.value;
            tunePixelColorText.value = tunePixelColor.value;
            tunePreset.value = 'custom';
            updateExportField();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        tunePixelColorText.addEventListener('input', () => {
            const val = tunePixelColorText.value;
            if (/^#[0-9A-Fa-f]{6}$/.test(val)) {
                CONFIG.pixelColor = val;
                tunePixelColor.value = val;
                tunePreset.value = 'custom';
                updateExportField();
                if (frames.length > 0) {
                    showFrame(currentFrame);
                }
            }
        });

        // Pulse scale handler (absolute pixels)
        tunePulseScale.addEventListener('input', () => {
            CONFIG.pulseScalePixels = parseInt(tunePulseScale.value);
            document.getElementById('tune-pulse-scale-val').textContent = `${CONFIG.pulseScalePixels}px`;
            updateExportField();
        });

        // Pulse glow handler
        tunePulseGlow.addEventListener('input', () => {
            CONFIG.pulseGlow = parseFloat(tunePulseGlow.value);
            document.getElementById('tune-pulse-glow-val').textContent = CONFIG.pulseGlow;
            updateExportField();
        });

        // Pulse brightness handler
        tunePulseBrightness.addEventListener('input', () => {
            CONFIG.pulseBrightness = parseFloat(tunePulseBrightness.value);
            document.getElementById('tune-pulse-brightness-val').textContent = CONFIG.pulseBrightness;
            updateExportField();
        });

        // Pulse frequency handler
        tunePulseFrequency.addEventListener('input', () => {
            CONFIG.pulseFrequency = parseFloat(tunePulseFrequency.value);
            document.getElementById('tune-pulse-frequency-val').textContent = CONFIG.pulseFrequency;
            updateExportField();
        });

        // Pulse curve handler
        tunePulseCurve.addEventListener('change', () => {
            CONFIG.pulseCurve = tunePulseCurve.value;
            updateExportField();
        });

        // Font selection handler (needs regeneration)
        tuneFont.addEventListener('change', async () => {
            CONFIG.fontFamily = tuneFont.value;
            updateExportField();
            // Regenerate frames with new font
            loading.classList.remove('hidden');
            await generateFrames();
            updateFrameExportSizeEstimate();
        });

        // Outline hide level handler (live update)
        tuneOutlineHide.addEventListener('input', () => {
            CONFIG.outlineHideFromLevel = parseInt(tuneOutlineHide.value);
            const displayVal = CONFIG.outlineHideFromLevel === 0 ? 'nie' : `ab Level ${CONFIG.outlineHideFromLevel}`;
            document.getElementById('tune-outline-hide-val').textContent = displayVal;
            updateExportField();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Single-line font size handler (needs regeneration)
        tuneSinglelineFontsize.addEventListener('input', () => {
            CONFIG.fontSize = parseInt(tuneSinglelineFontsize.value);
            document.getElementById('tune-singleline-fontsize-val').textContent = `${CONFIG.fontSize}px`;
            updateExportField();
        });

        // Two-line breakpoint handler (live update - switches mode)
        tuneTwolineBreakpoint.addEventListener('input', () => {
            CONFIG.twoLineBreakpoint = parseInt(tuneTwolineBreakpoint.value);
            document.getElementById('tune-twoline-breakpoint-val').textContent = `${CONFIG.twoLineBreakpoint}px`;
            updateExportField();
        });

        // Two-line WIAI size handler (needs regeneration)
        tuneTwolineWiai.addEventListener('input', () => {
            CONFIG.twoLineWiaiSize = parseInt(tuneTwolineWiai.value);
            document.getElementById('tune-twoline-wiai-val').textContent = `${CONFIG.twoLineWiaiSize}px`;
            updateExportField();
        });

        // Two-line 25 size handler (needs regeneration)
        tuneTwoline25.addEventListener('input', () => {
            CONFIG.twoLine25Size = parseInt(tuneTwoline25.value);
            document.getElementById('tune-twoline-25-val').textContent = `${CONFIG.twoLine25Size}px`;
            updateExportField();
        });

        // Two-line gap handler (needs regeneration)
        tuneTwolineGap.addEventListener('input', () => {
            CONFIG.twoLineGap = parseInt(tuneTwolineGap.value);
            document.getElementById('tune-twoline-gap-val').textContent = `${CONFIG.twoLineGap}px`;
            updateExportField();
        });

        // Fade limit levels handler (live update)
        tuneFadeLimitLevels.addEventListener('input', () => {
            CONFIG.fadeLimitLevels = parseInt(tuneFadeLimitLevels.value);
            document.getElementById('tune-fade-limit-levels-val').textContent = CONFIG.fadeLimitLevels;
            updateExportField();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Fade limit step handler (live update)
        tuneFadeLimitStep.addEventListener('input', () => {
            CONFIG.fadeLimitStep = parseFloat(tuneFadeLimitStep.value);
            document.getElementById('tune-fade-limit-step-val').textContent = `${Math.round(CONFIG.fadeLimitStep * 100)}%`;
            updateExportField();
            if (frames.length > 0) {
                showFrame(currentFrame);
            }
        });

        // Canvas width handler (needs regeneration)
        tuneCanvasWidth.addEventListener('input', () => {
            CONFIG.canvasWidth = parseInt(tuneCanvasWidth.value);
            document.getElementById('tune-canvas-width-val').textContent = `${CONFIG.canvasWidth}px`;
            updateExportField();
        });

        // Canvas height handler (needs regeneration)
        tuneCanvasHeight.addEventListener('input', () => {
            CONFIG.canvasHeight = parseInt(tuneCanvasHeight.value);
            document.getElementById('tune-canvas-height-val').textContent = `${CONFIG.canvasHeight}px`;
            updateExportField();
        });

        // Text Y offset handler (needs regeneration)
        tuneTextOffsetY.addEventListener('input', () => {
            CONFIG.textOffsetY = parseInt(tuneTextOffsetY.value);
            document.getElementById('tune-text-offset-y-val').textContent = `${CONFIG.textOffsetY}px`;
            updateExportField();
        });

        document.getElementById('copy-btn').addEventListener('click', () => {
            exportField.select();
            navigator.clipboard.writeText(exportField.value);
            document.getElementById('copy-btn').textContent = 'Copied!';
            setTimeout(() => {
                document.getElementById('copy-btn').textContent = 'Copy';
            }, 1500);
        });

        document.getElementById('apply-btn').addEventListener('click', async () => {
            // Try to parse JSON from export field first
            try {
                const jsonStr = exportField.value.trim();
                if (jsonStr) {
                    const params = JSON.parse(jsonStr);

                    // Apply all parsed values to CONFIG
                    if (params.bgColor !== undefined) CONFIG.bgColor = params.bgColor;
                    if (params.pixelColor !== undefined) CONFIG.pixelColor = params.pixelColor;
                    if (params.pixelOpacity !== undefined) CONFIG.pixelOpacity = params.pixelOpacity;
                    if (params.overlapThreshold !== undefined) CONFIG.overlapThreshold = params.overlapThreshold;
                    if (params.outlineStrokeWidth !== undefined) CONFIG.outlineStrokeWidth = params.outlineStrokeWidth;
                    if (params.outlineColor !== undefined) CONFIG.outlineColor = params.outlineColor;
                    if (params.shufflePixels !== undefined) CONFIG.shufflePixels = params.shufflePixels;
                    if (params.fadeMode !== undefined) CONFIG.fadeMode = params.fadeMode;
                    if (params.fadeEveryNPixelsStart !== undefined) CONFIG.fadeEveryNPixelsStart = params.fadeEveryNPixelsStart;
                    if (params.fadeEveryNPixelsEnd !== undefined) CONFIG.fadeEveryNPixelsEnd = params.fadeEveryNPixelsEnd;
                    if (params.maxFadeStepsStart !== undefined) CONFIG.maxFadeStepsStart = params.maxFadeStepsStart;
                    if (params.maxFadeStepsEnd !== undefined) CONFIG.maxFadeStepsEnd = params.maxFadeStepsEnd;
                    if (params.maxPixelSize !== undefined) CONFIG.maxPixelSize = params.maxPixelSize;
                    if (params.minPixelSize !== undefined) CONFIG.minPixelSize = params.minPixelSize;
                    if (params.numLevels !== undefined) CONFIG.numLevels = params.numLevels;
                    if (params.fadeCurve !== undefined) CONFIG.fadeCurve = params.fadeCurve;
                    if (params.pixelSizeCurve !== undefined) CONFIG.pixelSizeCurve = params.pixelSizeCurve;
                    if (params.pulseScalePixels !== undefined) CONFIG.pulseScalePixels = params.pulseScalePixels;
                    if (params.pulseGlow !== undefined) CONFIG.pulseGlow = params.pulseGlow;
                    if (params.pulseBrightness !== undefined) CONFIG.pulseBrightness = params.pulseBrightness;
                    if (params.pulseFrequency !== undefined) CONFIG.pulseFrequency = params.pulseFrequency;
                    if (params.pulseCurve !== undefined) CONFIG.pulseCurve = params.pulseCurve;
                    // New parameters
                    if (params.fontFamily !== undefined) CONFIG.fontFamily = params.fontFamily;
                    if (params.outlineHideFromLevel !== undefined) CONFIG.outlineHideFromLevel = params.outlineHideFromLevel;
                    if (params.twoLineBreakpoint !== undefined) CONFIG.twoLineBreakpoint = params.twoLineBreakpoint;
                    if (params.twoLineWiaiSize !== undefined) CONFIG.twoLineWiaiSize = params.twoLineWiaiSize;
                    if (params.twoLine25Size !== undefined) CONFIG.twoLine25Size = params.twoLine25Size;
                    if (params.twoLineGap !== undefined) CONFIG.twoLineGap = params.twoLineGap;
                    if (params.fadeLimitLevels !== undefined) CONFIG.fadeLimitLevels = params.fadeLimitLevels;
                    if (params.fadeLimitStep !== undefined) CONFIG.fadeLimitStep = params.fadeLimitStep;
                    if (params.canvasWidth !== undefined) CONFIG.canvasWidth = params.canvasWidth;
                    if (params.canvasHeight !== undefined) CONFIG.canvasHeight = params.canvasHeight;
                    if (params.textOffsetY !== undefined) CONFIG.textOffsetY = params.textOffsetY;

                    // Update all UI elements to match CONFIG
                    initializeSliders();
                    updateTuningDisplay();
                    drawCurveEditor();
                    drawPixelCurveEditor();

                    // Set preset to custom since we loaded external values
                    tunePreset.value = 'custom';
                }
            } catch (e) {
                console.warn('Could not parse JSON from export field, using current slider values:', e);
            }

            // Reset and regenerate
            frames = [];
            levelStats = [];
            historyLevels = [];
            allPixelsWithTiming = [];
            loading.classList.remove('hidden');
            await generateFrames();
            updateFrameExportSizeEstimate();
        });

        // Frame export event handlers
        document.getElementById('compress-export').addEventListener('change', updateFrameExportSizeEstimate);
        document.getElementById('save-frames-btn').addEventListener('click', exportFramesToFile);

        // Initialize sliders from CONFIG
        function initializeSliders() {
            tuneOpacity.value = CONFIG.pixelOpacity;
            tuneOverlap.value = CONFIG.overlapThreshold;
            tuneStroke.value = CONFIG.outlineStrokeWidth;
            tuneOutlineColor.value = CONFIG.outlineColor;
            tuneOrder.value = CONFIG.shufflePixels ? 'shuffle' : 'scanline';
            tuneFadeMode.value = CONFIG.fadeMode;
            tuneFadeNStart.value = CONFIG.fadeEveryNPixelsStart;
            tuneFadeNEnd.value = CONFIG.fadeEveryNPixelsEnd;
            tuneMaxFadeStart.value = CONFIG.maxFadeStepsStart;
            tuneMaxFadeEnd.value = CONFIG.maxFadeStepsEnd;
            // Pixel size curve sliders
            tuneMaxPixel.value = CONFIG.maxPixelSize;
            tuneMinPixel.value = CONFIG.minPixelSize;
            tuneNumLevels.value = CONFIG.numLevels;
            document.getElementById('tune-max-pixel-val').textContent = `${CONFIG.maxPixelSize}px`;
            document.getElementById('tune-min-pixel-val').textContent = `${CONFIG.minPixelSize}px`;
            document.getElementById('tune-num-levels-val').textContent = CONFIG.numLevels;
            // Color controls
            tuneBgColor.value = CONFIG.bgColor;
            tuneBgColorText.value = CONFIG.bgColor;
            tunePixelColor.value = CONFIG.pixelColor;
            tunePixelColorText.value = CONFIG.pixelColor;
            // Pulse controls
            tunePulseScale.value = CONFIG.pulseScalePixels;
            document.getElementById('tune-pulse-scale-val').textContent = `${CONFIG.pulseScalePixels}px`;
            tunePulseGlow.value = CONFIG.pulseGlow;
            document.getElementById('tune-pulse-glow-val').textContent = CONFIG.pulseGlow;
            tunePulseBrightness.value = CONFIG.pulseBrightness;
            document.getElementById('tune-pulse-brightness-val').textContent = CONFIG.pulseBrightness;
            tunePulseFrequency.value = CONFIG.pulseFrequency;
            document.getElementById('tune-pulse-frequency-val').textContent = CONFIG.pulseFrequency;
            tunePulseCurve.value = CONFIG.pulseCurve;
            // New controls
            tuneFont.value = CONFIG.fontFamily;
            tuneOutlineHide.value = CONFIG.outlineHideFromLevel;
            const outlineDisplayVal = CONFIG.outlineHideFromLevel === 0 ? 'nie' : `ab Level ${CONFIG.outlineHideFromLevel}`;
            document.getElementById('tune-outline-hide-val').textContent = outlineDisplayVal;
            tuneSinglelineFontsize.value = CONFIG.fontSize;
            document.getElementById('tune-singleline-fontsize-val').textContent = `${CONFIG.fontSize}px`;
            tuneTwolineBreakpoint.value = CONFIG.twoLineBreakpoint;
            document.getElementById('tune-twoline-breakpoint-val').textContent = `${CONFIG.twoLineBreakpoint}px`;
            tuneTwolineWiai.value = CONFIG.twoLineWiaiSize;
            document.getElementById('tune-twoline-wiai-val').textContent = `${CONFIG.twoLineWiaiSize}px`;
            tuneTwoline25.value = CONFIG.twoLine25Size;
            document.getElementById('tune-twoline-25-val').textContent = `${CONFIG.twoLine25Size}px`;
            tuneTwolineGap.value = CONFIG.twoLineGap;
            document.getElementById('tune-twoline-gap-val').textContent = `${CONFIG.twoLineGap}px`;
            // Fade limit controls
            tuneFadeLimitLevels.value = CONFIG.fadeLimitLevels;
            document.getElementById('tune-fade-limit-levels-val').textContent = CONFIG.fadeLimitLevels;
            tuneFadeLimitStep.value = CONFIG.fadeLimitStep;
            document.getElementById('tune-fade-limit-step-val').textContent = `${Math.round(CONFIG.fadeLimitStep * 100)}%`;
            // Canvas dimension controls
            tuneCanvasWidth.value = CONFIG.canvasWidth;
            document.getElementById('tune-canvas-width-val').textContent = `${CONFIG.canvasWidth}px`;
            tuneCanvasHeight.value = CONFIG.canvasHeight;
            document.getElementById('tune-canvas-height-val').textContent = `${CONFIG.canvasHeight}px`;
            tuneTextOffsetY.value = CONFIG.textOffsetY;
            document.getElementById('tune-text-offset-y-val').textContent = `${CONFIG.textOffsetY}px`;
        }

        // Pulse animation loop
        function startPulseAnimation() {
            function animate() {
                pulsePhase = (pulsePhase + CONFIG.pulseFrequency) % (Math.PI * 2);
                if (frames.length > 0 && !isPlaying) {
                    // Only re-render when not playing (playing already re-renders)
                    showFrame(currentFrame);
                }
                pulseAnimationId = requestAnimationFrame(animate);
            }
            if (!pulseAnimationId) {
                animate();
            }
        }

        // Wait for font to load, then generate
        document.fonts.ready.then(async () => {
            initializeSliders();
            updateTuningDisplay();
            await generateFrames();
            updateFrameExportSizeEstimate();
            startPulseAnimation();
        });
    </script>
</body>
</html>
