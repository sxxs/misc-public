<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Weihnachts-Katzen Jump</title>

    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#c0392b">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="JumpCat">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; 
            background-color: #2c3e50;
            touch-action: none;
            font-family: 'Fredoka One', cursive, sans-serif;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #fff;
            background: rgba(192, 57, 43, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            z-index: 10;
        }

        #status-bar {
            position: absolute;
            top: 70px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        
        .status-icon {
            font-size: 24px;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 15px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .active { opacity: 1; }

        #mute-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: #fff;
            background: rgba(44, 62, 80, 0.8);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            z-index: 20;
            border: 2px solid white;
        }

        .hidden {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .visible {
            visibility: visible;
            opacity: 1;
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 40px;
            margin-bottom: 10px;
            color: #e74c3c;
            -webkit-text-stroke: 1px white;
        }

        p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .blink {
            animation: blinker 1.5s linear infinite;
        }

        @keyframes blinker {
            50% { opacity: 0; }
        }
        
        .clickable-overlay {
            pointer-events: auto;
            background: rgba(0,0,0,0.4);
            padding: 30px;
            border-radius: 20px;
            width: 80%;
            max-width: 320px;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>

    <div id="score-display">Punkte: 0</div>
    <div id="status-bar">
        <div id="icon-heart" class="status-icon">‚ù§Ô∏è</div>
        <div id="icon-snow" class="status-icon">‚ùÑÔ∏è</div>
        <div id="icon-speed" class="status-icon">üöÄ</div>
    </div>
    <div id="mute-btn">üîä</div>
    
    <div id="ui-layer">
        <div id="start-screen" class="visible clickable-overlay">
            <h1>Weihnachts<br>Reise</h1>
            <p>1x Tippen = Sprung<br>2x Tippen = Doppelsprung</p>
            <p style="font-size: 14px; margin-top: 10px;">
                Erreiche 10, 20, 30 Punkte<br>um neue Welten zu sehen!
            </p>
            <p class="blink" style="margin-top: 20px;">Tippen zum Starten</p>
        </div>
        <div id="game-over-screen" class="hidden clickable-overlay">
            <h1>Oje!</h1>
            <p>Punkte: <span id="final-score">0</span></p>
            <p class="blink">Tippen f√ºr Neustart</p>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * Weihnachts-Katzen Jump & Run EVOLUTION
 * Version 5.0: Fairness Update & Dynamic Worlds
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiLayer = document.getElementById('ui-layer');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const scoreDisplay = document.getElementById('score-display');
const finalScoreSpan = document.getElementById('final-score');
const muteBtn = document.getElementById('mute-btn');

// Status Icons
const iconHeart = document.getElementById('icon-heart');
const iconSnow = document.getElementById('icon-snow');
const iconSpeed = document.getElementById('icon-speed');

// --- THEMES & COLORS ---
const THEMES = {
    0: { top: '#0b1c2c', bot: '#1e3c55', mtnNear: '#152a3d', mtnFar: '#0d1a26', text: 'Nacht' },
    10: { top: '#6D214F', bot: '#B33771', mtnNear: '#582c4d', mtnFar: '#2c1e30', text: 'Morgen' }, // Pink/Lila
    20: { top: '#74b9ff', bot: '#a29bfe', mtnNear: '#dfe6e9', mtnFar: '#b2bec3', text: 'Tag' }, // Eis/Blau
    30: { top: '#e17055', bot: '#fdcb6e', mtnNear: '#d63031', mtnFar: '#632c2c', text: 'Abend' }, // Orange
    40: { top: '#000000', bot: '#10ac84', mtnNear: '#006266', mtnFar: '#002a2a', text: 'Nordlicht' } // Gr√ºn/Schwarz
};

// --- AUDIO SYSTEM ---
const AudioEngine = {
    ctx: null, isPlaying: false, isMuted: false, tempo: 0.14, timerID: null, nextNoteTime: 0, noteIndex: 0,
    notes: { 'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88, 'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'FS4': 369.99, 'CS5': 554.37 },
    melody: [['A4', 3], ['G4', 1], ['FS4', 2], ['E4', 2], ['D4', 2], ['E4', 2], ['FS4', 2], ['D4', 2], ['E4', 1], ['FS4', 1], ['G4', 1], ['E4', 1], ['FS4', 3], ['E4', 1], ['D4', 2], ['CS5', 2], ['D4', 4]],

    init: function() { if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } if (this.ctx.state === 'suspended') this.ctx.resume(); },
    playSfx: function(type) {
        if (this.isMuted || !this.ctx) return;
        const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        if (type === 'jump') { osc.type = 'triangle'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(800, t + 0.15); gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2); }
        else if (type === 'powerup') { osc.type = 'sine'; osc.frequency.setValueAtTime(600, t); osc.frequency.linearRampToValueAtTime(1200, t + 0.3); gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.3); }
        else if (type === 'bad') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, t); osc.frequency.linearRampToValueAtTime(100, t + 0.3); gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.3); }
        else if (type === 'rescue') { osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(800, t + 0.1); osc.frequency.linearRampToValueAtTime(400, t + 0.2); osc.frequency.linearRampToValueAtTime(800, t + 0.3); gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.4); }
        osc.connect(gain); gain.connect(this.ctx.destination); osc.start(t); osc.stop(t + 0.4);
    },
    playTone: function(freq, duration) { if (this.isMuted || !this.ctx) return; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = 'square'; osc.frequency.value = freq; osc.connect(gain); gain.connect(this.ctx.destination); const now = this.nextNoteTime; osc.start(now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + duration - 0.05); osc.stop(now + duration); },
    scheduler: function() { if (!this.isPlaying) return; while (this.nextNoteTime < this.ctx.currentTime + 0.1) { this.scheduleNote(); } this.timerID = requestAnimationFrame(this.scheduler.bind(this)); },
    scheduleNote: function() { const noteData = this.melody[this.noteIndex]; const durationSeconds = noteData[1] * this.tempo; if (this.notes[noteData[0]]) this.playTone(this.notes[noteData[0]], durationSeconds); this.nextNoteTime += durationSeconds; this.noteIndex = (this.noteIndex + 1) % this.melody.length; },
    startMusic: function() { this.init(); if (!this.isPlaying) { this.isPlaying = true; this.noteIndex = 0; this.nextNoteTime = this.ctx.currentTime + 0.1; this.scheduler(); } },
    stopMusic: function() { this.isPlaying = false; if (this.timerID) cancelAnimationFrame(this.timerID); },
    toggleMute: function() { this.isMuted = !this.isMuted; if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); return this.isMuted; }
};
muteBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); AudioEngine.toggleMute(); muteBtn.innerText = AudioEngine.isMuted ? 'üîá' : 'üîä'; });
muteBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); AudioEngine.toggleMute(); muteBtn.innerText = AudioEngine.isMuted ? 'üîá' : 'üîä'; }, {passive: false});


// --- SPIEL VARIABLEN ---

let gameState = 'START';
let frames = 0;
let score = 0;
let baseSpeed = 5;
let currentSpeed = 5;
let gameOverTime = 0; 
let effectTimer = 0;
let activeEffect = null;
let hasRevive = false;

// --- CURRENT THEME ---
let currentTheme = THEMES[0];

let width, height;
function resize() { width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height; }
window.addEventListener('resize', resize);
resize();

// --- INPUT ---
function handleInput(e) {
    if (e.target.id === 'mute-btn') return;
    AudioEngine.init();
    if (e.type === 'touchstart') e.preventDefault();

    if (gameState === 'START') startGame(); 
    else if (gameState === 'PLAYING') cat.jump(); 
    else if (gameState === 'GAMEOVER') { if (Date.now() - gameOverTime > 800) resetGame(); }
}
window.addEventListener('touchstart', handleInput, {passive: false});
window.addEventListener('mousedown', handleInput);
window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') handleInput(e); });

// --- ITEMS & OBSTACLES ---
const ITEM_TYPES = {
    SNOW: { color: '#00d2d3', label: '‚ùÑÔ∏è' }, 
    ROCKET: { color: '#ff9f43', label: 'üöÄ' }, 
    HEART: { color: '#ff6b6b', label: '‚ù§Ô∏è' }, 
    GIFT: { color: '#feca57', label: 'üéÅ' }   
};

// --- GAME OBJECTS ---
const cat = {
    x: 50, y: 0, radius: 20, vy: 0, gravity: 0.55, jumpForce: -12, grounded: false, rotation: 0, jumpCount: 0, onPlatform: null, invincible: 0,
    reset: function() { this.x = width * 0.15; this.y = height / 2; this.vy = 0; this.rotation = 0; this.jumpCount = 0; this.onPlatform = null; this.invincible = 0; },
    jump: function() { if (this.grounded || this.jumpCount < 2) { this.vy = this.jumpForce; this.grounded = false; this.jumpCount++; AudioEngine.playSfx('jump'); createParticles(this.x, this.y + 20, 5, '#fff'); this.onPlatform = null; } },
    revive: function() { this.vy = -20; this.jumpCount = 1; this.grounded = false; this.invincible = 80; hasRevive = false; AudioEngine.playSfx('rescue'); createParticles(this.x, this.y, 20, '#ff6b6b'); updateUI(); },
    update: function() { this.vy += this.gravity; this.y += this.vy; if(this.invincible > 0) this.invincible--; 
        if (!this.grounded) this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.vy * 0.1))); else { this.rotation = 0; this.jumpCount = 0; if (this.onPlatform && this.onPlatform.dy) this.y += this.onPlatform.dy; }
        if (this.y + this.radius > height + 60) { if (hasRevive) this.revive(); else gameOver(); }
    },
    draw: function() {
        ctx.save(); ctx.translate(this.x, this.y);
        if (hasRevive) { ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(frames*0.1)*0.3})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.stroke(); }
        ctx.rotate(this.rotation);
        // Body
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(0, 10, 18, 14, 0, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(0, -5, 16, 0, Math.PI * 2); ctx.fill();
        // Ears
        ctx.beginPath(); ctx.moveTo(-12, -12); ctx.lineTo(-16, -22); ctx.lineTo(-4, -16); ctx.fill(); ctx.beginPath(); ctx.moveTo(12, -12); ctx.lineTo(16, -22); ctx.lineTo(4, -16); ctx.fill();
        // Face
        ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(-6, -6, 2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6, -6, 2, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'pink'; ctx.beginPath(); ctx.arc(0, -1, 2, 0, Math.PI*2); ctx.fill();
        // Hat
        ctx.rotate(Math.sin(frames * 0.1) * 0.1); ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.moveTo(-14, -10); ctx.quadraticCurveTo(0, -30, 20, -5); ctx.lineTo(14, -10); ctx.quadraticCurveTo(0, -16, -14, -10); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(20, -5, 4, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.roundRect(-15, -12, 30, 6, 3); ctx.fill();
        ctx.restore();
    }
};

const platforms = [];

class Platform {
    constructor(x, y, w, type = 'normal') {
        this.x = x; this.y = y; this.originalY = y; this.w = w; this.h = 40;
        this.type = type; this.passed = false; this.dy = 0; this.offset = Math.random() * Math.PI * 2;
        this.item = null; this.obstacle = null; 
        
        // SPAWN RATES (Fairer)
        if (w > 100) {
            const rand = Math.random();
            // Kerzen: Sehr selten am Anfang, etwas √∂fter sp√§ter, aber nie zu oft
            let candleChance = 0.05; // 5% Basis
            if (score > 20) candleChance = 0.15; 
            
            if (rand < candleChance && score > 5) { 
                this.obstacle = 'CANDLE';
                this.obsX = x + 30 + Math.random() * (w - 60);
            } else if (rand > 0.8) { // 20% Item Chance (hoch!)
                const r2 = Math.random();
                // Verteilung Items:
                if (r2 < 0.3) this.item = 'SNOW'; // 30% Slow
                else if (r2 < 0.35) this.item = 'ROCKET'; // Nur 5% Rakete (nervt am meisten)
                else if (r2 < 0.8) this.item = 'HEART'; // 45% Herz (sehr h√§ufig!)
                else this.item = 'GIFT'; // 20% Geschenk
                this.itemX = x + 20 + Math.random() * (w - 40);
            }
        }
        
        // Deko generieren
        this.lights = [];
        if (score >= 30) {
            let numLights = Math.floor(w / 30);
            for(let i=0; i<numLights; i++) {
                this.lights.push({x: i*30 + 10, color: Math.random()>0.5 ? '#e74c3c' : '#f1c40f'});
            }
        }
    }

    update() {
        this.x -= currentSpeed;
        if (this.obstacle) this.obsX -= currentSpeed;
        if (this.item) this.itemX -= currentSpeed;
        if (this.type === 'moving') { this.y = this.originalY + Math.sin((frames * 0.05) + this.offset) * 60; this.dy = Math.cos((frames * 0.05) + this.offset) * 60 * 0.05; } else { this.dy = 0; }
    }

    draw() {
        // Platform Body
        if (this.type === 'moving') ctx.fillStyle = '#a29bfe'; else ctx.fillStyle = '#ecf0f1'; 
        ctx.beginPath(); ctx.roundRect(this.x, this.y, this.w, this.h, 5); ctx.fill();
        
        // DEKO: Stufe 1 (ab 10 Pkt): Dicker Schnee oben drauf
        if (score >= 10) {
            ctx.fillStyle = '#fff';
            ctx.beginPath(); 
            ctx.roundRect(this.x - 2, this.y - 8, this.w + 4, 15, 8); 
            ctx.fill();
        } else {
            // Standard Schnee
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath(); ctx.rect(this.x, this.y, this.w, 10); ctx.fill();
        }

        // DEKO: Stufe 2 (ab 20 Pkt): Eiszapfen unten
        if (score >= 20) {
            ctx.fillStyle = 'rgba(223, 230, 233, 0.8)';
            for(let i=10; i<this.w-10; i+=25) {
                ctx.beginPath();
                ctx.moveTo(this.x + i, this.y + this.h);
                ctx.lineTo(this.x + i + 10, this.y + this.h);
                ctx.lineTo(this.x + i + 5, this.y + this.h + 15 + Math.sin(i)*5);
                ctx.fill();
            }
        }
        
        // DEKO: Stufe 3 (ab 30 Pkt): Lichterkette oder Tannenzweig
        if (score >= 30) {
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#2d3436';
            ctx.beginPath();
            ctx.moveTo(this.x, this.y + 5);
            ctx.bezierCurveTo(this.x + this.w/3, this.y + 15, this.x + 2*this.w/3, this.y + 5, this.x + this.w, this.y + 10);
            ctx.stroke();
            
            this.lights.forEach((l, idx) => {
                ctx.fillStyle = (Math.floor(frames/10) + idx) % 2 === 0 ? l.color : '#fff';
                ctx.beginPath(); ctx.arc(this.x + l.x, this.y + 10, 3, 0, Math.PI*2); ctx.fill();
            });
        }

        // Draw Candle
        if (this.obstacle === 'CANDLE') {
            ctx.fillStyle = '#e74c3c'; ctx.fillRect(this.obsX, this.y - 30, 10, 30);
            const fSize = 5 + Math.sin(frames * 0.5) * 2;
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(this.obsX + 5, this.y - 35, fSize, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(230, 126, 34, 0.5)'; ctx.beginPath(); ctx.arc(this.obsX + 5, this.y - 35, fSize*2, 0, Math.PI*2); ctx.fill();
        }

        // Draw Item
        if (this.item) {
            const yHover = this.y - 40 + Math.sin(frames * 0.1) * 5;
            const info = ITEM_TYPES[this.item];
            ctx.shadowBlur = 10; ctx.shadowColor = info.color;
            ctx.font = '24px Arial'; ctx.fillStyle = '#fff'; ctx.fillText(info.label, this.itemX, yHover);
            ctx.shadowBlur = 0;
        }
    }
}

// --- BACKGROUND & PARALLAX ---
function updateTheme() {
    // Finde das passende Theme basierend auf Score
    let themeKey = 0;
    if (score >= 40) themeKey = 40;
    else if (score >= 30) themeKey = 30;
    else if (score >= 20) themeKey = 20;
    else if (score >= 10) themeKey = 10;
    
    // Smooth transition logic k√∂nnte hier hin, wir machen harten Switch f√ºr Klarheit
    currentTheme = THEMES[themeKey];
}

function drawBackground() {
    updateTheme();
    
    let gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, currentTheme.top); 
    gradient.addColorStop(1, currentTheme.bot);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // Stars
    ctx.fillStyle = "#fff";
    for(let i=0; i<30; i++) {
        let sx = (i * 137) % width; let sy = (i * 93) % (height/1.5);
        ctx.globalAlpha = 0.3 + Math.sin(frames*0.02 + i)*0.3;
        ctx.beginPath(); ctx.arc(sx, sy, Math.random()*2, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1.0;
    
    // Theme Text (Hintergrund Info)
    if (score % 10 < 2 && score > 0) { // Zeige kurz an beim Wechsel
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.font = 'bold 80px Fredoka One';
        ctx.textAlign = 'center';
        ctx.fillText(currentTheme.text, width/2, height/3);
        ctx.textAlign = 'left'; // Reset
    }

    // Mountains
    ctx.fillStyle = currentTheme.mtnFar;
    drawParallaxLayer(0.1, (x) => {
        ctx.beginPath(); ctx.moveTo(x, height); ctx.lineTo(x + 200, height - 300); ctx.lineTo(x + 400, height - 100); ctx.lineTo(x + 600, height - 250); ctx.lineTo(x + 800, height); ctx.fill();
    }, 800);

    ctx.fillStyle = currentTheme.mtnNear;
    drawParallaxLayer(0.3, (x) => {
        ctx.beginPath(); ctx.moveTo(x, height); ctx.lineTo(x + 50, height - 100); ctx.lineTo(x + 100, height - 60); ctx.lineTo(x + 150, height - 120); ctx.lineTo(x + 300, height); ctx.fill();
        // Trees adapt to theme color lightly
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath(); ctx.moveTo(x+20, height); ctx.lineTo(x+35, height-80); ctx.lineTo(x+50, height); ctx.fill();
        ctx.fillStyle = currentTheme.mtnNear; // Reset
    }, 400);
}

function drawParallaxLayer(speedFactor, drawFn, segmentWidth) {
    let moveSpeed = (gameState === 'PLAYING') ? currentSpeed : 0.5;
    let totalDist = frames * moveSpeed * speedFactor;
    let offset = totalDist % segmentWidth;
    let count = Math.ceil(width / segmentWidth) + 1;
    for(let i = 0; i < count; i++) { drawFn((i * segmentWidth) - offset); }
}

// Particles
let particles = [];
class Particle {
    constructor(x, y, size, color) { this.x = x; this.y = y; this.size = size; this.color = color; this.life = 1.0; this.speedX = (Math.random() - 0.5) * 3; this.speedY = (Math.random() - 0.5) * 3; }
    update() { this.x += this.speedX; this.y += this.speedY; this.life -= 0.03; }
    draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; }
}
function createParticles(x, y, count, color) { for(let i=0; i<count; i++) particles.push(new Particle(x, y, Math.random()*4+2, color)); }

// --- LOGIK ---
function activateEffect(type) {
    AudioEngine.playSfx('powerup');
    if (type === 'SNOW') { activeEffect = 'slow'; effectTimer = 300; currentSpeed = 3; } 
    else if (type === 'ROCKET') { activeEffect = 'fast'; effectTimer = 180; currentSpeed = 9; AudioEngine.playSfx('bad'); } 
    else if (type === 'HEART') { hasRevive = true; } 
    else if (type === 'GIFT') { activateEffect('SNOW'); hasRevive = true; score += 20; createParticles(cat.x, cat.y, 50, '#f1c40f'); }
    updateUI();
}

function updateUI() {
    iconHeart.classList.toggle('active', hasRevive);
    iconSnow.classList.toggle('active', activeEffect === 'slow');
    iconSpeed.classList.toggle('active', activeEffect === 'fast');
    scoreDisplay.innerText = "Punkte: " + score;
}

function startGame() {
    cat.reset(); platforms.length = 0; score = 0; baseSpeed = 5; currentSpeed = baseSpeed; hasRevive = false; activeEffect = null; effectTimer = 0;
    platforms.push(new Platform(50, height - 150, 800)); 
    generatePlatform(); updateUI();
    startScreen.classList.remove('visible'); startScreen.classList.add('hidden');
    gameOverScreen.classList.remove('visible'); gameOverScreen.classList.add('hidden');
    AudioEngine.startMusic(); gameState = 'PLAYING';
}

function generatePlatform() {
    let lastPlat = platforms[platforms.length - 1];
    let gap = 80 + Math.random() * 100;
    let newX = lastPlat.x + lastPlat.w + gap;
    let yVariance = (Math.random() * 160) - 80;
    let newY = lastPlat.originalY + yVariance;
    if (newY < 200) newY = 200; if (newY > height - 100) newY = height - 100;
    let type = (score > 15 && Math.random() > 0.7) ? 'moving' : 'normal';
    platforms.push(new Platform(newX, newY, 150 + Math.random() * 150, type));
}

function checkCollision() {
    cat.grounded = false; cat.onPlatform = null;
    for (let p of platforms) {
        if (cat.x + 5 > p.x && cat.x - 5 < p.x + p.w && cat.y + cat.radius >= p.y && cat.y + cat.radius <= p.y + p.h + 15 && cat.vy >= 0) {
            cat.grounded = true; cat.vy = 0; cat.y = p.y - cat.radius; cat.jumpCount = 0; cat.onPlatform = p;
        }
        if (p.obstacle === 'CANDLE') {
            if (Math.abs(cat.x - (p.obsX + 5)) < 15 && Math.abs(cat.y - (p.y - 15)) < 25) { if (cat.invincible <= 0) { if (hasRevive) { cat.revive(); p.obstacle = null; } else { gameOver(); } } }
        }
        if (p.item) { if (Math.abs(cat.x - p.itemX) < 30 && Math.abs(cat.y - (p.y - 40)) < 40) { activateEffect(p.item); p.item = null; } }
        if (!p.passed && p.x + p.w < cat.x) { score++; p.passed = true; updateUI(); if (score % 5 === 0 && baseSpeed < 9) baseSpeed += 0.2; }
    }
}

function gameOver() {
    if (gameState === 'GAMEOVER') return;
    gameState = 'GAMEOVER'; gameOverTime = Date.now(); finalScoreSpan.innerText = score;
    gameOverScreen.classList.remove('hidden'); gameOverScreen.classList.add('visible');
    AudioEngine.stopMusic(); AudioEngine.playSfx('bad');
}

function resetGame() { startGame(); }
requestAnimationFrame(loop);

function loop() {
    ctx.clearRect(0, 0, width, height);
    drawBackground();

    if (gameState === 'PLAYING') {
        frames++;
        if (activeEffect) { effectTimer--; if (effectTimer <= 0) activeEffect = null; }
        let targetSpeed = baseSpeed; if (activeEffect === 'slow') targetSpeed = 3; if (activeEffect === 'fast') targetSpeed = 9;
        currentSpeed += (targetSpeed - currentSpeed) * 0.05;

        if (platforms.length > 0) { let lastX = platforms[platforms.length - 1].x; if (lastX < width + 300) generatePlatform(); }
        if (platforms.length > 0 && platforms[0].x + platforms[0].w < -200) platforms.shift();

        platforms.forEach(p => p.update()); cat.update(); checkCollision();
    }
    platforms.forEach(p => p.draw()); cat.draw();
    particles.forEach((p, index) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(index, 1); });
    updateUI(); requestAnimationFrame(loop);
}

// Service Worker Registration
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('SW registered'))
      .catch(err => console.log('SW registration failed:', err));
  });
}
</script>
</body>
</html>